"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/async-validator";
exports.ids = ["vendor-chunks/async-validator"];
exports.modules = {

/***/ "(ssr)/./node_modules/async-validator/dist-web/index.js":
/*!********************************************************!*\
  !*** ./node_modules/async-validator/dist-web/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Schema)\n/* harmony export */ });\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _construct(Parent, args, Class) {\n    if (_isNativeReflectConstruct()) {\n        _construct = Reflect.construct.bind();\n    } else {\n        _construct = function _construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (Class === null || !_isNativeFunction(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n}\n/* eslint no-console:0 */ var formatRegExp = /%[sdj%]/g;\nvar warning = function warning() {}; // don't print warning message when in production env or node runtime\nif (typeof process !== \"undefined\" && process.env && \"development\" !== \"production\" && \"undefined\" !== \"undefined\" && 0) {}\nfunction convertFieldsError(errors) {\n    if (!errors || !errors.length) return null;\n    var fields = {};\n    errors.forEach(function(error) {\n        var field = error.field;\n        fields[field] = fields[field] || [];\n        fields[field].push(error);\n    });\n    return fields;\n}\nfunction format(template) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    var i = 0;\n    var len = args.length;\n    if (typeof template === \"function\") {\n        return template.apply(null, args);\n    }\n    if (typeof template === \"string\") {\n        var str = template.replace(formatRegExp, function(x) {\n            if (x === \"%%\") {\n                return \"%\";\n            }\n            if (i >= len) {\n                return x;\n            }\n            switch(x){\n                case \"%s\":\n                    return String(args[i++]);\n                case \"%d\":\n                    return Number(args[i++]);\n                case \"%j\":\n                    try {\n                        return JSON.stringify(args[i++]);\n                    } catch (_) {\n                        return \"[Circular]\";\n                    }\n                    break;\n                default:\n                    return x;\n            }\n        });\n        return str;\n    }\n    return template;\n}\nfunction isNativeStringType(type) {\n    return type === \"string\" || type === \"url\" || type === \"hex\" || type === \"email\" || type === \"date\" || type === \"pattern\";\n}\nfunction isEmptyValue(value, type) {\n    if (value === undefined || value === null) {\n        return true;\n    }\n    if (type === \"array\" && Array.isArray(value) && !value.length) {\n        return true;\n    }\n    if (isNativeStringType(type) && typeof value === \"string\" && !value) {\n        return true;\n    }\n    return false;\n}\nfunction asyncParallelArray(arr, func, callback) {\n    var results = [];\n    var total = 0;\n    var arrLength = arr.length;\n    function count(errors) {\n        results.push.apply(results, errors || []);\n        total++;\n        if (total === arrLength) {\n            callback(results);\n        }\n    }\n    arr.forEach(function(a) {\n        func(a, count);\n    });\n}\nfunction asyncSerialArray(arr, func, callback) {\n    var index = 0;\n    var arrLength = arr.length;\n    function next(errors) {\n        if (errors && errors.length) {\n            callback(errors);\n            return;\n        }\n        var original = index;\n        index = index + 1;\n        if (original < arrLength) {\n            func(arr[original], next);\n        } else {\n            callback([]);\n        }\n    }\n    next([]);\n}\nfunction flattenObjArr(objArr) {\n    var ret = [];\n    Object.keys(objArr).forEach(function(k) {\n        ret.push.apply(ret, objArr[k] || []);\n    });\n    return ret;\n}\nvar AsyncValidationError = /*#__PURE__*/ function(_Error) {\n    _inheritsLoose(AsyncValidationError, _Error);\n    function AsyncValidationError(errors, fields) {\n        var _this;\n        _this = _Error.call(this, \"Async Validation Error\") || this;\n        _this.errors = errors;\n        _this.fields = fields;\n        return _this;\n    }\n    return AsyncValidationError;\n}(/*#__PURE__*/ _wrapNativeSuper(Error));\nfunction asyncMap(objArr, option, func, callback, source) {\n    if (option.first) {\n        var _pending = new Promise(function(resolve, reject) {\n            var next = function next(errors) {\n                callback(errors);\n                return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);\n            };\n            var flattenArr = flattenObjArr(objArr);\n            asyncSerialArray(flattenArr, func, next);\n        });\n        _pending[\"catch\"](function(e) {\n            return e;\n        });\n        return _pending;\n    }\n    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];\n    var objArrKeys = Object.keys(objArr);\n    var objArrLength = objArrKeys.length;\n    var total = 0;\n    var results = [];\n    var pending = new Promise(function(resolve, reject) {\n        var next = function next(errors) {\n            results.push.apply(results, errors);\n            total++;\n            if (total === objArrLength) {\n                callback(results);\n                return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);\n            }\n        };\n        if (!objArrKeys.length) {\n            callback(results);\n            resolve(source);\n        }\n        objArrKeys.forEach(function(key) {\n            var arr = objArr[key];\n            if (firstFields.indexOf(key) !== -1) {\n                asyncSerialArray(arr, func, next);\n            } else {\n                asyncParallelArray(arr, func, next);\n            }\n        });\n    });\n    pending[\"catch\"](function(e) {\n        return e;\n    });\n    return pending;\n}\nfunction isErrorObj(obj) {\n    return !!(obj && obj.message !== undefined);\n}\nfunction getValue(value, path) {\n    var v = value;\n    for(var i = 0; i < path.length; i++){\n        if (v == undefined) {\n            return v;\n        }\n        v = v[path[i]];\n    }\n    return v;\n}\nfunction complementError(rule, source) {\n    return function(oe) {\n        var fieldValue;\n        if (rule.fullFields) {\n            fieldValue = getValue(source, rule.fullFields);\n        } else {\n            fieldValue = source[oe.field || rule.fullField];\n        }\n        if (isErrorObj(oe)) {\n            oe.field = oe.field || rule.fullField;\n            oe.fieldValue = fieldValue;\n            return oe;\n        }\n        return {\n            message: typeof oe === \"function\" ? oe() : oe,\n            fieldValue: fieldValue,\n            field: oe.field || rule.fullField\n        };\n    };\n}\nfunction deepMerge(target, source) {\n    if (source) {\n        for(var s in source){\n            if (source.hasOwnProperty(s)) {\n                var value = source[s];\n                if (typeof value === \"object\" && typeof target[s] === \"object\") {\n                    target[s] = _extends({}, target[s], value);\n                } else {\n                    target[s] = value;\n                }\n            }\n        }\n    }\n    return target;\n}\nvar required$1 = function required(rule, value, source, errors, options, type) {\n    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {\n        errors.push(format(options.messages.required, rule.fullField));\n    }\n};\n/**\n *  Rule for validating whitespace.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */ var whitespace = function whitespace(rule, value, source, errors, options) {\n    if (/^\\s+$/.test(value) || value === \"\") {\n        errors.push(format(options.messages.whitespace, rule.fullField));\n    }\n};\n// https://github.com/kevva/url-regex/blob/master/index.js\nvar urlReg;\nvar getUrlRegex = function() {\n    if (urlReg) {\n        return urlReg;\n    }\n    var word = \"[a-fA-F\\\\d:]\";\n    var b = function b(options) {\n        return options && options.includeBoundaries ? \"(?:(?<=\\\\s|^)(?=\" + word + \")|(?<=\" + word + \")(?=\\\\s|$))\" : \"\";\n    };\n    var v4 = \"(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}\";\n    var v6seg = \"[a-fA-F\\\\d]{1,4}\";\n    var v6 = (\"\\n(?:\\n(?:\" + v6seg + \":){7}(?:\" + v6seg + \"|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\\n(?:\" + v6seg + \":){6}(?:\" + v4 + \"|:\" + v6seg + \"|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\\n(?:\" + v6seg + \":){5}(?::\" + v4 + \"|(?::\" + v6seg + \"){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\\n(?:\" + v6seg + \":){4}(?:(?::\" + v6seg + \"){0,1}:\" + v4 + \"|(?::\" + v6seg + \"){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\\n(?:\" + v6seg + \":){3}(?:(?::\" + v6seg + \"){0,2}:\" + v4 + \"|(?::\" + v6seg + \"){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\\n(?:\" + v6seg + \":){2}(?:(?::\" + v6seg + \"){0,3}:\" + v4 + \"|(?::\" + v6seg + \"){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\\n(?:\" + v6seg + \":){1}(?:(?::\" + v6seg + \"){0,4}:\" + v4 + \"|(?::\" + v6seg + \"){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\\n(?::(?:(?::\" + v6seg + \"){0,5}:\" + v4 + \"|(?::\" + v6seg + \"){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\\n\").replace(/\\s*\\/\\/.*$/gm, \"\").replace(/\\n/g, \"\").trim(); // Pre-compile only the exact regexes because adding a global flag make regexes stateful\n    var v46Exact = new RegExp(\"(?:^\" + v4 + \"$)|(?:^\" + v6 + \"$)\");\n    var v4exact = new RegExp(\"^\" + v4 + \"$\");\n    var v6exact = new RegExp(\"^\" + v6 + \"$\");\n    var ip = function ip(options) {\n        return options && options.exact ? v46Exact : new RegExp(\"(?:\" + b(options) + v4 + b(options) + \")|(?:\" + b(options) + v6 + b(options) + \")\", \"g\");\n    };\n    ip.v4 = function(options) {\n        return options && options.exact ? v4exact : new RegExp(\"\" + b(options) + v4 + b(options), \"g\");\n    };\n    ip.v6 = function(options) {\n        return options && options.exact ? v6exact : new RegExp(\"\" + b(options) + v6 + b(options), \"g\");\n    };\n    var protocol = \"(?:(?:[a-z]+:)?//)\";\n    var auth = \"(?:\\\\S+(?::\\\\S*)?@)?\";\n    var ipv4 = ip.v4().source;\n    var ipv6 = ip.v6().source;\n    var host = \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\";\n    var domain = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\";\n    var tld = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\";\n    var port = \"(?::\\\\d{2,5})?\";\n    var path = '(?:[/?#][^\\\\s\"]*)?';\n    var regex = \"(?:\" + protocol + \"|www\\\\.)\" + auth + \"(?:localhost|\" + ipv4 + \"|\" + ipv6 + \"|\" + host + domain + tld + \")\" + port + path;\n    urlReg = new RegExp(\"(?:^\" + regex + \"$)\", \"i\");\n    return urlReg;\n};\n/* eslint max-len:0 */ var pattern$2 = {\n    // http://emailregex.com/\n    email: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+\\.)+[a-zA-Z\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}))$/,\n    // url: new RegExp(\n    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\\\S+(?::\\\\S*)?@)?(?:(?:(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[0-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,})))|localhost)(?::\\\\d{2,5})?(?:(/|\\\\?|#)[^\\\\s]*)?$',\n    //   'i',\n    // ),\n    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i\n};\nvar types = {\n    integer: function integer(value) {\n        return types.number(value) && parseInt(value, 10) === value;\n    },\n    \"float\": function float(value) {\n        return types.number(value) && !types.integer(value);\n    },\n    array: function array(value) {\n        return Array.isArray(value);\n    },\n    regexp: function regexp(value) {\n        if (value instanceof RegExp) {\n            return true;\n        }\n        try {\n            return !!new RegExp(value);\n        } catch (e) {\n            return false;\n        }\n    },\n    date: function date(value) {\n        return typeof value.getTime === \"function\" && typeof value.getMonth === \"function\" && typeof value.getYear === \"function\" && !isNaN(value.getTime());\n    },\n    number: function number(value) {\n        if (isNaN(value)) {\n            return false;\n        }\n        return typeof value === \"number\";\n    },\n    object: function object(value) {\n        return typeof value === \"object\" && !types.array(value);\n    },\n    method: function method(value) {\n        return typeof value === \"function\";\n    },\n    email: function email(value) {\n        return typeof value === \"string\" && value.length <= 320 && !!value.match(pattern$2.email);\n    },\n    url: function url(value) {\n        return typeof value === \"string\" && value.length <= 2048 && !!value.match(getUrlRegex());\n    },\n    hex: function hex(value) {\n        return typeof value === \"string\" && !!value.match(pattern$2.hex);\n    }\n};\nvar type$1 = function type(rule, value, source, errors, options) {\n    if (rule.required && value === undefined) {\n        required$1(rule, value, source, errors, options);\n        return;\n    }\n    var custom = [\n        \"integer\",\n        \"float\",\n        \"array\",\n        \"regexp\",\n        \"object\",\n        \"method\",\n        \"email\",\n        \"number\",\n        \"date\",\n        \"url\",\n        \"hex\"\n    ];\n    var ruleType = rule.type;\n    if (custom.indexOf(ruleType) > -1) {\n        if (!types[ruleType](value)) {\n            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));\n        } // straight typeof check\n    } else if (ruleType && typeof value !== rule.type) {\n        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));\n    }\n};\nvar range = function range(rule, value, source, errors, options) {\n    var len = typeof rule.len === \"number\";\n    var min = typeof rule.min === \"number\";\n    var max = typeof rule.max === \"number\"; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）\n    var spRegexp = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    var val = value;\n    var key = null;\n    var num = typeof value === \"number\";\n    var str = typeof value === \"string\";\n    var arr = Array.isArray(value);\n    if (num) {\n        key = \"number\";\n    } else if (str) {\n        key = \"string\";\n    } else if (arr) {\n        key = \"array\";\n    } // if the value is not of a supported type for range validation\n    // the validation rule rule should use the\n    // type property to also test for a particular type\n    if (!key) {\n        return false;\n    }\n    if (arr) {\n        val = value.length;\n    }\n    if (str) {\n        // 处理码点大于U+010000的文字length属性不准确的bug，如\"𠮷𠮷𠮷\".lenght !== 3\n        val = value.replace(spRegexp, \"_\").length;\n    }\n    if (len) {\n        if (val !== rule.len) {\n            errors.push(format(options.messages[key].len, rule.fullField, rule.len));\n        }\n    } else if (min && !max && val < rule.min) {\n        errors.push(format(options.messages[key].min, rule.fullField, rule.min));\n    } else if (max && !min && val > rule.max) {\n        errors.push(format(options.messages[key].max, rule.fullField, rule.max));\n    } else if (min && max && (val < rule.min || val > rule.max)) {\n        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));\n    }\n};\nvar ENUM$1 = \"enum\";\nvar enumerable$1 = function enumerable(rule, value, source, errors, options) {\n    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];\n    if (rule[ENUM$1].indexOf(value) === -1) {\n        errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(\", \")));\n    }\n};\nvar pattern$1 = function pattern(rule, value, source, errors, options) {\n    if (rule.pattern) {\n        if (rule.pattern instanceof RegExp) {\n            // if a RegExp instance is passed, reset `lastIndex` in case its `global`\n            // flag is accidentally set to `true`, which in a validation scenario\n            // is not necessary and the result might be misleading\n            rule.pattern.lastIndex = 0;\n            if (!rule.pattern.test(value)) {\n                errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n            }\n        } else if (typeof rule.pattern === \"string\") {\n            var _pattern = new RegExp(rule.pattern);\n            if (!_pattern.test(value)) {\n                errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n            }\n        }\n    }\n};\nvar rules = {\n    required: required$1,\n    whitespace: whitespace,\n    type: type$1,\n    range: range,\n    \"enum\": enumerable$1,\n    pattern: pattern$1\n};\nvar string = function string(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value, \"string\") && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options, \"string\");\n        if (!isEmptyValue(value, \"string\")) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n            rules.pattern(rule, value, source, errors, options);\n            if (rule.whitespace === true) {\n                rules.whitespace(rule, value, source, errors, options);\n            }\n        }\n    }\n    callback(errors);\n};\nvar method = function method(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar number = function number(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (value === \"\") {\n            value = undefined;\n        }\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar _boolean = function _boolean(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar regexp = function regexp(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (!isEmptyValue(value)) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar integer = function integer(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar floatFn = function floatFn(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar array = function array(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if ((value === undefined || value === null) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options, \"array\");\n        if (value !== undefined && value !== null) {\n            rules.type(rule, value, source, errors, options);\n            rules.range(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar object = function object(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar ENUM = \"enum\";\nvar enumerable = function enumerable(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (value !== undefined) {\n            rules[ENUM](rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar pattern = function pattern(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value, \"string\") && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (!isEmptyValue(value, \"string\")) {\n            rules.pattern(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar date = function date(rule, value, callback, source, options) {\n    // console.log('integer rule called %j', rule);\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);\n    if (validate) {\n        if (isEmptyValue(value, \"date\") && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n        if (!isEmptyValue(value, \"date\")) {\n            var dateObject;\n            if (value instanceof Date) {\n                dateObject = value;\n            } else {\n                dateObject = new Date(value);\n            }\n            rules.type(rule, dateObject, source, errors, options);\n            if (dateObject) {\n                rules.range(rule, dateObject.getTime(), source, errors, options);\n            }\n        }\n    }\n    callback(errors);\n};\nvar required = function required(rule, value, callback, source, options) {\n    var errors = [];\n    var type = Array.isArray(value) ? \"array\" : typeof value;\n    rules.required(rule, value, source, errors, options, type);\n    callback(errors);\n};\nvar type = function type(rule, value, callback, source, options) {\n    var ruleType = rule.type;\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value, ruleType) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options, ruleType);\n        if (!isEmptyValue(value, ruleType)) {\n            rules.type(rule, value, source, errors, options);\n        }\n    }\n    callback(errors);\n};\nvar any = function any(rule, value, callback, source, options) {\n    var errors = [];\n    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback();\n        }\n        rules.required(rule, value, source, errors, options);\n    }\n    callback(errors);\n};\nvar validators = {\n    string: string,\n    method: method,\n    number: number,\n    \"boolean\": _boolean,\n    regexp: regexp,\n    integer: integer,\n    \"float\": floatFn,\n    array: array,\n    object: object,\n    \"enum\": enumerable,\n    pattern: pattern,\n    date: date,\n    url: type,\n    hex: type,\n    email: type,\n    required: required,\n    any: any\n};\nfunction newMessages() {\n    return {\n        \"default\": \"Validation error on field %s\",\n        required: \"%s is required\",\n        \"enum\": \"%s must be one of %s\",\n        whitespace: \"%s cannot be empty\",\n        date: {\n            format: \"%s date %s is invalid for format %s\",\n            parse: \"%s date could not be parsed, %s is invalid \",\n            invalid: \"%s date %s is invalid\"\n        },\n        types: {\n            string: \"%s is not a %s\",\n            method: \"%s is not a %s (function)\",\n            array: \"%s is not an %s\",\n            object: \"%s is not an %s\",\n            number: \"%s is not a %s\",\n            date: \"%s is not a %s\",\n            \"boolean\": \"%s is not a %s\",\n            integer: \"%s is not an %s\",\n            \"float\": \"%s is not a %s\",\n            regexp: \"%s is not a valid %s\",\n            email: \"%s is not a valid %s\",\n            url: \"%s is not a valid %s\",\n            hex: \"%s is not a valid %s\"\n        },\n        string: {\n            len: \"%s must be exactly %s characters\",\n            min: \"%s must be at least %s characters\",\n            max: \"%s cannot be longer than %s characters\",\n            range: \"%s must be between %s and %s characters\"\n        },\n        number: {\n            len: \"%s must equal %s\",\n            min: \"%s cannot be less than %s\",\n            max: \"%s cannot be greater than %s\",\n            range: \"%s must be between %s and %s\"\n        },\n        array: {\n            len: \"%s must be exactly %s in length\",\n            min: \"%s cannot be less than %s in length\",\n            max: \"%s cannot be greater than %s in length\",\n            range: \"%s must be between %s and %s in length\"\n        },\n        pattern: {\n            mismatch: \"%s value %s does not match pattern %s\"\n        },\n        clone: function clone() {\n            var cloned = JSON.parse(JSON.stringify(this));\n            cloned.clone = this.clone;\n            return cloned;\n        }\n    };\n}\nvar messages = newMessages();\n/**\n *  Encapsulates a validation schema.\n *\n *  @param descriptor An object declaring validation rules\n *  for this schema.\n */ var Schema = /*#__PURE__*/ function() {\n    // ========================= Static =========================\n    // ======================== Instance ========================\n    function Schema(descriptor) {\n        this.rules = null;\n        this._messages = messages;\n        this.define(descriptor);\n    }\n    var _proto = Schema.prototype;\n    _proto.define = function define(rules) {\n        var _this = this;\n        if (!rules) {\n            throw new Error(\"Cannot configure a schema with no rules\");\n        }\n        if (typeof rules !== \"object\" || Array.isArray(rules)) {\n            throw new Error(\"Rules must be an object\");\n        }\n        this.rules = {};\n        Object.keys(rules).forEach(function(name) {\n            var item = rules[name];\n            _this.rules[name] = Array.isArray(item) ? item : [\n                item\n            ];\n        });\n    };\n    _proto.messages = function messages(_messages) {\n        if (_messages) {\n            this._messages = deepMerge(newMessages(), _messages);\n        }\n        return this._messages;\n    };\n    _proto.validate = function validate(source_, o, oc) {\n        var _this2 = this;\n        if (o === void 0) {\n            o = {};\n        }\n        if (oc === void 0) {\n            oc = function oc() {};\n        }\n        var source = source_;\n        var options = o;\n        var callback = oc;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        if (!this.rules || Object.keys(this.rules).length === 0) {\n            if (callback) {\n                callback(null, source);\n            }\n            return Promise.resolve(source);\n        }\n        function complete(results) {\n            var errors = [];\n            var fields = {};\n            function add(e) {\n                if (Array.isArray(e)) {\n                    var _errors;\n                    errors = (_errors = errors).concat.apply(_errors, e);\n                } else {\n                    errors.push(e);\n                }\n            }\n            for(var i = 0; i < results.length; i++){\n                add(results[i]);\n            }\n            if (!errors.length) {\n                callback(null, source);\n            } else {\n                fields = convertFieldsError(errors);\n                callback(errors, fields);\n            }\n        }\n        if (options.messages) {\n            var messages$1 = this.messages();\n            if (messages$1 === messages) {\n                messages$1 = newMessages();\n            }\n            deepMerge(messages$1, options.messages);\n            options.messages = messages$1;\n        } else {\n            options.messages = this.messages();\n        }\n        var series = {};\n        var keys = options.keys || Object.keys(this.rules);\n        keys.forEach(function(z) {\n            var arr = _this2.rules[z];\n            var value = source[z];\n            arr.forEach(function(r) {\n                var rule = r;\n                if (typeof rule.transform === \"function\") {\n                    if (source === source_) {\n                        source = _extends({}, source);\n                    }\n                    value = source[z] = rule.transform(value);\n                }\n                if (typeof rule === \"function\") {\n                    rule = {\n                        validator: rule\n                    };\n                } else {\n                    rule = _extends({}, rule);\n                } // Fill validator. Skip if nothing need to validate\n                rule.validator = _this2.getValidationMethod(rule);\n                if (!rule.validator) {\n                    return;\n                }\n                rule.field = z;\n                rule.fullField = rule.fullField || z;\n                rule.type = _this2.getType(rule);\n                series[z] = series[z] || [];\n                series[z].push({\n                    rule: rule,\n                    value: value,\n                    source: source,\n                    field: z\n                });\n            });\n        });\n        var errorFields = {};\n        return asyncMap(series, options, function(data, doIt) {\n            var rule = data.rule;\n            var deep = (rule.type === \"object\" || rule.type === \"array\") && (typeof rule.fields === \"object\" || typeof rule.defaultField === \"object\");\n            deep = deep && (rule.required || !rule.required && data.value);\n            rule.field = data.field;\n            function addFullField(key, schema) {\n                return _extends({}, schema, {\n                    fullField: rule.fullField + \".\" + key,\n                    fullFields: rule.fullFields ? [].concat(rule.fullFields, [\n                        key\n                    ]) : [\n                        key\n                    ]\n                });\n            }\n            function cb(e) {\n                if (e === void 0) {\n                    e = [];\n                }\n                var errorList = Array.isArray(e) ? e : [\n                    e\n                ];\n                if (!options.suppressWarning && errorList.length) {\n                    Schema.warning(\"async-validator:\", errorList);\n                }\n                if (errorList.length && rule.message !== undefined) {\n                    errorList = [].concat(rule.message);\n                } // Fill error info\n                var filledErrors = errorList.map(complementError(rule, source));\n                if (options.first && filledErrors.length) {\n                    errorFields[rule.field] = 1;\n                    return doIt(filledErrors);\n                }\n                if (!deep) {\n                    doIt(filledErrors);\n                } else {\n                    // if rule is required but the target object\n                    // does not exist fail at the rule level and don't\n                    // go deeper\n                    if (rule.required && !data.value) {\n                        if (rule.message !== undefined) {\n                            filledErrors = [].concat(rule.message).map(complementError(rule, source));\n                        } else if (options.error) {\n                            filledErrors = [\n                                options.error(rule, format(options.messages.required, rule.field))\n                            ];\n                        }\n                        return doIt(filledErrors);\n                    }\n                    var fieldsSchema = {};\n                    if (rule.defaultField) {\n                        Object.keys(data.value).map(function(key) {\n                            fieldsSchema[key] = rule.defaultField;\n                        });\n                    }\n                    fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);\n                    var paredFieldsSchema = {};\n                    Object.keys(fieldsSchema).forEach(function(field) {\n                        var fieldSchema = fieldsSchema[field];\n                        var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [\n                            fieldSchema\n                        ];\n                        paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));\n                    });\n                    var schema = new Schema(paredFieldsSchema);\n                    schema.messages(options.messages);\n                    if (data.rule.options) {\n                        data.rule.options.messages = options.messages;\n                        data.rule.options.error = options.error;\n                    }\n                    schema.validate(data.value, data.rule.options || options, function(errs) {\n                        var finalErrors = [];\n                        if (filledErrors && filledErrors.length) {\n                            finalErrors.push.apply(finalErrors, filledErrors);\n                        }\n                        if (errs && errs.length) {\n                            finalErrors.push.apply(finalErrors, errs);\n                        }\n                        doIt(finalErrors.length ? finalErrors : null);\n                    });\n                }\n            }\n            var res;\n            if (rule.asyncValidator) {\n                res = rule.asyncValidator(rule, data.value, cb, data.source, options);\n            } else if (rule.validator) {\n                try {\n                    res = rule.validator(rule, data.value, cb, data.source, options);\n                } catch (error) {\n                    console.error == null ? void 0 : console.error(error); // rethrow to report error\n                    if (!options.suppressValidatorError) {\n                        setTimeout(function() {\n                            throw error;\n                        }, 0);\n                    }\n                    cb(error.message);\n                }\n                if (res === true) {\n                    cb();\n                } else if (res === false) {\n                    cb(typeof rule.message === \"function\" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + \" fails\");\n                } else if (res instanceof Array) {\n                    cb(res);\n                } else if (res instanceof Error) {\n                    cb(res.message);\n                }\n            }\n            if (res && res.then) {\n                res.then(function() {\n                    return cb();\n                }, function(e) {\n                    return cb(e);\n                });\n            }\n        }, function(results) {\n            complete(results);\n        }, source);\n    };\n    _proto.getType = function getType(rule) {\n        if (rule.type === undefined && rule.pattern instanceof RegExp) {\n            rule.type = \"pattern\";\n        }\n        if (typeof rule.validator !== \"function\" && rule.type && !validators.hasOwnProperty(rule.type)) {\n            throw new Error(format(\"Unknown rule type %s\", rule.type));\n        }\n        return rule.type || \"string\";\n    };\n    _proto.getValidationMethod = function getValidationMethod(rule) {\n        if (typeof rule.validator === \"function\") {\n            return rule.validator;\n        }\n        var keys = Object.keys(rule);\n        var messageIndex = keys.indexOf(\"message\");\n        if (messageIndex !== -1) {\n            keys.splice(messageIndex, 1);\n        }\n        if (keys.length === 1 && keys[0] === \"required\") {\n            return validators.required;\n        }\n        return validators[this.getType(rule)] || undefined;\n    };\n    return Schema;\n}();\nSchema.register = function register(type, validator) {\n    if (typeof validator !== \"function\") {\n        throw new Error(\"Cannot register a validator by type, validator is not a function\");\n    }\n    validators[type] = validator;\n};\nSchema.warning = warning;\nSchema.messages = messages;\nSchema.validators = validators;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXN5bmMtdmFsaWRhdG9yL2Rpc3Qtd2ViL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFTQTtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFFekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBRUEsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBRUEsU0FBU1EsZUFBZUMsUUFBUSxFQUFFQyxVQUFVO0lBQzFDRCxTQUFTTCxTQUFTLEdBQUdULE9BQU9nQixNQUFNLENBQUNELFdBQVdOLFNBQVM7SUFDdkRLLFNBQVNMLFNBQVMsQ0FBQ1EsV0FBVyxHQUFHSDtJQUVqQ0ksZ0JBQWdCSixVQUFVQztBQUM1QjtBQUVBLFNBQVNJLGdCQUFnQkMsQ0FBQztJQUN4QkQsa0JBQWtCbkIsT0FBT3FCLGNBQWMsR0FBR3JCLE9BQU9zQixjQUFjLENBQUNwQixJQUFJLEtBQUssU0FBU2lCLGdCQUFnQkMsQ0FBQztRQUNqRyxPQUFPQSxFQUFFRyxTQUFTLElBQUl2QixPQUFPc0IsY0FBYyxDQUFDRjtJQUM5QztJQUNBLE9BQU9ELGdCQUFnQkM7QUFDekI7QUFFQSxTQUFTRixnQkFBZ0JFLENBQUMsRUFBRUksQ0FBQztJQUMzQk4sa0JBQWtCbEIsT0FBT3FCLGNBQWMsR0FBR3JCLE9BQU9xQixjQUFjLENBQUNuQixJQUFJLEtBQUssU0FBU2dCLGdCQUFnQkUsQ0FBQyxFQUFFSSxDQUFDO1FBQ3BHSixFQUFFRyxTQUFTLEdBQUdDO1FBQ2QsT0FBT0o7SUFDVDtJQUNBLE9BQU9GLGdCQUFnQkUsR0FBR0k7QUFDNUI7QUFFQSxTQUFTQztJQUNQLElBQUksT0FBT0MsWUFBWSxlQUFlLENBQUNBLFFBQVFDLFNBQVMsRUFBRSxPQUFPO0lBQ2pFLElBQUlELFFBQVFDLFNBQVMsQ0FBQ0MsSUFBSSxFQUFFLE9BQU87SUFDbkMsSUFBSSxPQUFPQyxVQUFVLFlBQVksT0FBTztJQUV4QyxJQUFJO1FBQ0ZDLFFBQVFyQixTQUFTLENBQUNzQixPQUFPLENBQUNwQixJQUFJLENBQUNlLFFBQVFDLFNBQVMsQ0FBQ0csU0FBUyxFQUFFLEVBQUUsWUFBYTtRQUMzRSxPQUFPO0lBQ1QsRUFBRSxPQUFPRSxHQUFHO1FBQ1YsT0FBTztJQUNUO0FBQ0Y7QUFFQSxTQUFTQyxXQUFXQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSztJQUNyQyxJQUFJWCw2QkFBNkI7UUFDL0JRLGFBQWFQLFFBQVFDLFNBQVMsQ0FBQ3pCLElBQUk7SUFDckMsT0FBTztRQUNMK0IsYUFBYSxTQUFTQSxXQUFXQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSztZQUNsRCxJQUFJQyxJQUFJO2dCQUFDO2FBQUs7WUFDZEEsRUFBRUMsSUFBSSxDQUFDMUIsS0FBSyxDQUFDeUIsR0FBR0Y7WUFDaEIsSUFBSUksY0FBY0MsU0FBU3RDLElBQUksQ0FBQ1UsS0FBSyxDQUFDc0IsUUFBUUc7WUFDOUMsSUFBSUksV0FBVyxJQUFJRjtZQUNuQixJQUFJSCxPQUFPbEIsZ0JBQWdCdUIsVUFBVUwsTUFBTTNCLFNBQVM7WUFDcEQsT0FBT2dDO1FBQ1Q7SUFDRjtJQUVBLE9BQU9SLFdBQVdyQixLQUFLLENBQUMsTUFBTVA7QUFDaEM7QUFFQSxTQUFTcUMsa0JBQWtCQyxFQUFFO0lBQzNCLE9BQU9ILFNBQVNJLFFBQVEsQ0FBQ2pDLElBQUksQ0FBQ2dDLElBQUlFLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQztBQUNsRTtBQUVBLFNBQVNDLGlCQUFpQlYsS0FBSztJQUM3QixJQUFJVyxTQUFTLE9BQU9DLFFBQVEsYUFBYSxJQUFJQSxRQUFRQztJQUVyREgsbUJBQW1CLFNBQVNBLGlCQUFpQlYsS0FBSztRQUNoRCxJQUFJQSxVQUFVLFFBQVEsQ0FBQ00sa0JBQWtCTixRQUFRLE9BQU9BO1FBRXhELElBQUksT0FBT0EsVUFBVSxZQUFZO1lBQy9CLE1BQU0sSUFBSWMsVUFBVTtRQUN0QjtRQUVBLElBQUksT0FBT0gsV0FBVyxhQUFhO1lBQ2pDLElBQUlBLE9BQU9JLEdBQUcsQ0FBQ2YsUUFBUSxPQUFPVyxPQUFPSyxHQUFHLENBQUNoQjtZQUV6Q1csT0FBT00sR0FBRyxDQUFDakIsT0FBT2tCO1FBQ3BCO1FBRUEsU0FBU0E7WUFDUCxPQUFPckIsV0FBV0csT0FBTy9CLFdBQVdjLGdCQUFnQixJQUFJLEVBQUVGLFdBQVc7UUFDdkU7UUFFQXFDLFFBQVE3QyxTQUFTLEdBQUdULE9BQU9nQixNQUFNLENBQUNvQixNQUFNM0IsU0FBUyxFQUFFO1lBQ2pEUSxhQUFhO2dCQUNYc0MsT0FBT0Q7Z0JBQ1BFLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1ZDLGNBQWM7WUFDaEI7UUFDRjtRQUNBLE9BQU94QyxnQkFBZ0JvQyxTQUFTbEI7SUFDbEM7SUFFQSxPQUFPVSxpQkFBaUJWO0FBQzFCO0FBRUEsdUJBQXVCLEdBQ3ZCLElBQUl1QixlQUFlO0FBQ25CLElBQUlDLFVBQVUsU0FBU0EsV0FBVyxHQUFHLHFFQUFxRTtBQUUxRyxJQUFJLE9BQU9DLFlBQVksZUFBZUEsUUFBUUMsR0FBRyxJQUFJRCxrQkFBeUIsZ0JBQWdCLGdCQUFrQixlQUFlLENBQW9CLEVBQWEsRUFVL0o7QUFFRCxTQUFTUyxtQkFBbUJMLE1BQU07SUFDaEMsSUFBSSxDQUFDQSxVQUFVLENBQUNBLE9BQU8zRCxNQUFNLEVBQUUsT0FBTztJQUN0QyxJQUFJaUUsU0FBUyxDQUFDO0lBQ2ROLE9BQU9PLE9BQU8sQ0FBQyxTQUFVQyxLQUFLO1FBQzVCLElBQUlDLFFBQVFELE1BQU1DLEtBQUs7UUFDdkJILE1BQU0sQ0FBQ0csTUFBTSxHQUFHSCxNQUFNLENBQUNHLE1BQU0sSUFBSSxFQUFFO1FBQ25DSCxNQUFNLENBQUNHLE1BQU0sQ0FBQ3BDLElBQUksQ0FBQ21DO0lBQ3JCO0lBQ0EsT0FBT0Y7QUFDVDtBQUNBLFNBQVNJLE9BQU9DLFFBQVE7SUFDdEIsSUFBSyxJQUFJQyxPQUFPeEUsVUFBVUMsTUFBTSxFQUFFNkIsT0FBTyxJQUFJMkMsTUFBTUQsT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUUsT0FBTyxHQUFHQSxPQUFPRixNQUFNRSxPQUFRO1FBQzFHNUMsSUFBSSxDQUFDNEMsT0FBTyxFQUFFLEdBQUcxRSxTQUFTLENBQUMwRSxLQUFLO0lBQ2xDO0lBRUEsSUFBSTNFLElBQUk7SUFDUixJQUFJNEUsTUFBTTdDLEtBQUs3QixNQUFNO0lBRXJCLElBQUksT0FBT3NFLGFBQWEsWUFBWTtRQUNsQyxPQUFPQSxTQUFTaEUsS0FBSyxDQUFDLE1BQU11QjtJQUM5QjtJQUVBLElBQUksT0FBT3lDLGFBQWEsVUFBVTtRQUNoQyxJQUFJSyxNQUFNTCxTQUFTTSxPQUFPLENBQUN2QixjQUFjLFNBQVV3QixDQUFDO1lBQ2xELElBQUlBLE1BQU0sTUFBTTtnQkFDZCxPQUFPO1lBQ1Q7WUFFQSxJQUFJL0UsS0FBSzRFLEtBQUs7Z0JBQ1osT0FBT0c7WUFDVDtZQUVBLE9BQVFBO2dCQUNOLEtBQUs7b0JBQ0gsT0FBT0MsT0FBT2pELElBQUksQ0FBQy9CLElBQUk7Z0JBRXpCLEtBQUs7b0JBQ0gsT0FBT2lGLE9BQU9sRCxJQUFJLENBQUMvQixJQUFJO2dCQUV6QixLQUFLO29CQUNILElBQUk7d0JBQ0YsT0FBT2tGLEtBQUtDLFNBQVMsQ0FBQ3BELElBQUksQ0FBQy9CLElBQUk7b0JBQ2pDLEVBQUUsT0FBT29GLEdBQUc7d0JBQ1YsT0FBTztvQkFDVDtvQkFFQTtnQkFFRjtvQkFDRSxPQUFPTDtZQUNYO1FBQ0Y7UUFDQSxPQUFPRjtJQUNUO0lBRUEsT0FBT0w7QUFDVDtBQUVBLFNBQVNhLG1CQUFtQnpCLElBQUk7SUFDOUIsT0FBT0EsU0FBUyxZQUFZQSxTQUFTLFNBQVNBLFNBQVMsU0FBU0EsU0FBUyxXQUFXQSxTQUFTLFVBQVVBLFNBQVM7QUFDbEg7QUFFQSxTQUFTMEIsYUFBYW5DLEtBQUssRUFBRVMsSUFBSTtJQUMvQixJQUFJVCxVQUFVTixhQUFhTSxVQUFVLE1BQU07UUFDekMsT0FBTztJQUNUO0lBRUEsSUFBSVMsU0FBUyxXQUFXYyxNQUFNYSxPQUFPLENBQUNwQyxVQUFVLENBQUNBLE1BQU1qRCxNQUFNLEVBQUU7UUFDN0QsT0FBTztJQUNUO0lBRUEsSUFBSW1GLG1CQUFtQnpCLFNBQVMsT0FBT1QsVUFBVSxZQUFZLENBQUNBLE9BQU87UUFDbkUsT0FBTztJQUNUO0lBRUEsT0FBTztBQUNUO0FBRUEsU0FBU3FDLG1CQUFtQkMsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLFFBQVE7SUFDN0MsSUFBSUMsVUFBVSxFQUFFO0lBQ2hCLElBQUlDLFFBQVE7SUFDWixJQUFJQyxZQUFZTCxJQUFJdkYsTUFBTTtJQUUxQixTQUFTNkYsTUFBTWxDLE1BQU07UUFDbkIrQixRQUFRMUQsSUFBSSxDQUFDMUIsS0FBSyxDQUFDb0YsU0FBUy9CLFVBQVUsRUFBRTtRQUN4Q2dDO1FBRUEsSUFBSUEsVUFBVUMsV0FBVztZQUN2QkgsU0FBU0M7UUFDWDtJQUNGO0lBRUFILElBQUlyQixPQUFPLENBQUMsU0FBVW5DLENBQUM7UUFDckJ5RCxLQUFLekQsR0FBRzhEO0lBQ1Y7QUFDRjtBQUVBLFNBQVNDLGlCQUFpQlAsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLFFBQVE7SUFDM0MsSUFBSU0sUUFBUTtJQUNaLElBQUlILFlBQVlMLElBQUl2RixNQUFNO0lBRTFCLFNBQVNnRyxLQUFLckMsTUFBTTtRQUNsQixJQUFJQSxVQUFVQSxPQUFPM0QsTUFBTSxFQUFFO1lBQzNCeUYsU0FBUzlCO1lBQ1Q7UUFDRjtRQUVBLElBQUlzQyxXQUFXRjtRQUNmQSxRQUFRQSxRQUFRO1FBRWhCLElBQUlFLFdBQVdMLFdBQVc7WUFDeEJKLEtBQUtELEdBQUcsQ0FBQ1UsU0FBUyxFQUFFRDtRQUN0QixPQUFPO1lBQ0xQLFNBQVMsRUFBRTtRQUNiO0lBQ0Y7SUFFQU8sS0FBSyxFQUFFO0FBQ1Q7QUFFQSxTQUFTRSxjQUFjQyxNQUFNO0lBQzNCLElBQUlDLE1BQU0sRUFBRTtJQUNaMUcsT0FBTzJHLElBQUksQ0FBQ0YsUUFBUWpDLE9BQU8sQ0FBQyxTQUFVb0MsQ0FBQztRQUNyQ0YsSUFBSXBFLElBQUksQ0FBQzFCLEtBQUssQ0FBQzhGLEtBQUtELE1BQU0sQ0FBQ0csRUFBRSxJQUFJLEVBQUU7SUFDckM7SUFDQSxPQUFPRjtBQUNUO0FBRUEsSUFBSUcsdUJBQXVCLFdBQVcsR0FBRSxTQUFVQyxNQUFNO0lBQ3REakcsZUFBZWdHLHNCQUFzQkM7SUFFckMsU0FBU0QscUJBQXFCNUMsTUFBTSxFQUFFTSxNQUFNO1FBQzFDLElBQUl3QztRQUVKQSxRQUFRRCxPQUFPbkcsSUFBSSxDQUFDLElBQUksRUFBRSw2QkFBNkIsSUFBSTtRQUMzRG9HLE1BQU05QyxNQUFNLEdBQUdBO1FBQ2Y4QyxNQUFNeEMsTUFBTSxHQUFHQTtRQUNmLE9BQU93QztJQUNUO0lBRUEsT0FBT0Y7QUFDVCxFQUFHLFdBQVcsR0FBRS9ELGlCQUFpQmtFO0FBQ2pDLFNBQVNDLFNBQVNSLE1BQU0sRUFBRVMsTUFBTSxFQUFFcEIsSUFBSSxFQUFFQyxRQUFRLEVBQUV4RixNQUFNO0lBQ3RELElBQUkyRyxPQUFPQyxLQUFLLEVBQUU7UUFDaEIsSUFBSUMsV0FBVyxJQUFJQyxRQUFRLFNBQVVDLE9BQU8sRUFBRUMsTUFBTTtZQUNsRCxJQUFJakIsT0FBTyxTQUFTQSxLQUFLckMsTUFBTTtnQkFDN0I4QixTQUFTOUI7Z0JBQ1QsT0FBT0EsT0FBTzNELE1BQU0sR0FBR2lILE9BQU8sSUFBSVYscUJBQXFCNUMsUUFBUUssbUJBQW1CTCxZQUFZcUQsUUFBUS9HO1lBQ3hHO1lBRUEsSUFBSWlILGFBQWFoQixjQUFjQztZQUMvQkwsaUJBQWlCb0IsWUFBWTFCLE1BQU1RO1FBQ3JDO1FBRUFjLFFBQVEsQ0FBQyxRQUFRLENBQUMsU0FBVXBGLENBQUM7WUFDM0IsT0FBT0E7UUFDVDtRQUVBLE9BQU9vRjtJQUNUO0lBRUEsSUFBSUssY0FBY1AsT0FBT08sV0FBVyxLQUFLLE9BQU96SCxPQUFPMkcsSUFBSSxDQUFDRixVQUFVUyxPQUFPTyxXQUFXLElBQUksRUFBRTtJQUM5RixJQUFJQyxhQUFhMUgsT0FBTzJHLElBQUksQ0FBQ0Y7SUFDN0IsSUFBSWtCLGVBQWVELFdBQVdwSCxNQUFNO0lBQ3BDLElBQUkyRixRQUFRO0lBQ1osSUFBSUQsVUFBVSxFQUFFO0lBQ2hCLElBQUk0QixVQUFVLElBQUlQLFFBQVEsU0FBVUMsT0FBTyxFQUFFQyxNQUFNO1FBQ2pELElBQUlqQixPQUFPLFNBQVNBLEtBQUtyQyxNQUFNO1lBQzdCK0IsUUFBUTFELElBQUksQ0FBQzFCLEtBQUssQ0FBQ29GLFNBQVMvQjtZQUM1QmdDO1lBRUEsSUFBSUEsVUFBVTBCLGNBQWM7Z0JBQzFCNUIsU0FBU0M7Z0JBQ1QsT0FBT0EsUUFBUTFGLE1BQU0sR0FBR2lILE9BQU8sSUFBSVYscUJBQXFCYixTQUFTMUIsbUJBQW1CMEIsYUFBYXNCLFFBQVEvRztZQUMzRztRQUNGO1FBRUEsSUFBSSxDQUFDbUgsV0FBV3BILE1BQU0sRUFBRTtZQUN0QnlGLFNBQVNDO1lBQ1RzQixRQUFRL0c7UUFDVjtRQUVBbUgsV0FBV2xELE9BQU8sQ0FBQyxTQUFVaEUsR0FBRztZQUM5QixJQUFJcUYsTUFBTVksTUFBTSxDQUFDakcsSUFBSTtZQUVyQixJQUFJaUgsWUFBWTVFLE9BQU8sQ0FBQ3JDLFNBQVMsQ0FBQyxHQUFHO2dCQUNuQzRGLGlCQUFpQlAsS0FBS0MsTUFBTVE7WUFDOUIsT0FBTztnQkFDTFYsbUJBQW1CQyxLQUFLQyxNQUFNUTtZQUNoQztRQUNGO0lBQ0Y7SUFDQXNCLE9BQU8sQ0FBQyxRQUFRLENBQUMsU0FBVTVGLENBQUM7UUFDMUIsT0FBT0E7SUFDVDtJQUNBLE9BQU80RjtBQUNUO0FBRUEsU0FBU0MsV0FBV0MsR0FBRztJQUNyQixPQUFPLENBQUMsQ0FBRUEsQ0FBQUEsT0FBT0EsSUFBSUMsT0FBTyxLQUFLOUUsU0FBUTtBQUMzQztBQUVBLFNBQVMrRSxTQUFTekUsS0FBSyxFQUFFMEUsSUFBSTtJQUMzQixJQUFJQyxJQUFJM0U7SUFFUixJQUFLLElBQUluRCxJQUFJLEdBQUdBLElBQUk2SCxLQUFLM0gsTUFBTSxFQUFFRixJQUFLO1FBQ3BDLElBQUk4SCxLQUFLakYsV0FBVztZQUNsQixPQUFPaUY7UUFDVDtRQUVBQSxJQUFJQSxDQUFDLENBQUNELElBQUksQ0FBQzdILEVBQUUsQ0FBQztJQUNoQjtJQUVBLE9BQU84SDtBQUNUO0FBRUEsU0FBU0MsZ0JBQWdCQyxJQUFJLEVBQUU3SCxNQUFNO0lBQ25DLE9BQU8sU0FBVThILEVBQUU7UUFDakIsSUFBSUM7UUFFSixJQUFJRixLQUFLRyxVQUFVLEVBQUU7WUFDbkJELGFBQWFOLFNBQVN6SCxRQUFRNkgsS0FBS0csVUFBVTtRQUMvQyxPQUFPO1lBQ0xELGFBQWEvSCxNQUFNLENBQUM4SCxHQUFHM0QsS0FBSyxJQUFJMEQsS0FBS0ksU0FBUyxDQUFDO1FBQ2pEO1FBRUEsSUFBSVgsV0FBV1EsS0FBSztZQUNsQkEsR0FBRzNELEtBQUssR0FBRzJELEdBQUczRCxLQUFLLElBQUkwRCxLQUFLSSxTQUFTO1lBQ3JDSCxHQUFHQyxVQUFVLEdBQUdBO1lBQ2hCLE9BQU9EO1FBQ1Q7UUFFQSxPQUFPO1lBQ0xOLFNBQVMsT0FBT00sT0FBTyxhQUFhQSxPQUFPQTtZQUMzQ0MsWUFBWUE7WUFDWjVELE9BQU8yRCxHQUFHM0QsS0FBSyxJQUFJMEQsS0FBS0ksU0FBUztRQUNuQztJQUNGO0FBQ0Y7QUFDQSxTQUFTQyxVQUFVdEksTUFBTSxFQUFFSSxNQUFNO0lBQy9CLElBQUlBLFFBQVE7UUFDVixJQUFLLElBQUltSSxLQUFLbkksT0FBUTtZQUNwQixJQUFJQSxPQUFPRyxjQUFjLENBQUNnSSxJQUFJO2dCQUM1QixJQUFJbkYsUUFBUWhELE1BQU0sQ0FBQ21JLEVBQUU7Z0JBRXJCLElBQUksT0FBT25GLFVBQVUsWUFBWSxPQUFPcEQsTUFBTSxDQUFDdUksRUFBRSxLQUFLLFVBQVU7b0JBQzlEdkksTUFBTSxDQUFDdUksRUFBRSxHQUFHM0ksU0FBUyxDQUFDLEdBQUdJLE1BQU0sQ0FBQ3VJLEVBQUUsRUFBRW5GO2dCQUN0QyxPQUFPO29CQUNMcEQsTUFBTSxDQUFDdUksRUFBRSxHQUFHbkY7Z0JBQ2Q7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPcEQ7QUFDVDtBQUVBLElBQUl3SSxhQUFhLFNBQVNDLFNBQVNSLElBQUksRUFBRTdFLEtBQUssRUFBRWhELE1BQU0sRUFBRTBELE1BQU0sRUFBRTRFLE9BQU8sRUFBRTdFLElBQUk7SUFDM0UsSUFBSW9FLEtBQUtRLFFBQVEsSUFBSyxFQUFDckksT0FBT0csY0FBYyxDQUFDMEgsS0FBSzFELEtBQUssS0FBS2dCLGFBQWFuQyxPQUFPUyxRQUFRb0UsS0FBS3BFLElBQUksSUFBSTtRQUNuR0MsT0FBTzNCLElBQUksQ0FBQ3FDLE9BQU9rRSxRQUFRQyxRQUFRLENBQUNGLFFBQVEsRUFBRVIsS0FBS0ksU0FBUztJQUM5RDtBQUNGO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUVELElBQUlPLGFBQWEsU0FBU0EsV0FBV1gsSUFBSSxFQUFFN0UsS0FBSyxFQUFFaEQsTUFBTSxFQUFFMEQsTUFBTSxFQUFFNEUsT0FBTztJQUN2RSxJQUFJLFFBQVFHLElBQUksQ0FBQ3pGLFVBQVVBLFVBQVUsSUFBSTtRQUN2Q1UsT0FBTzNCLElBQUksQ0FBQ3FDLE9BQU9rRSxRQUFRQyxRQUFRLENBQUNDLFVBQVUsRUFBRVgsS0FBS0ksU0FBUztJQUNoRTtBQUNGO0FBRUEsMERBQTBEO0FBQzFELElBQUlTO0FBQ0osSUFBSUMsY0FBZTtJQUNqQixJQUFJRCxRQUFRO1FBQ1YsT0FBT0E7SUFDVDtJQUVBLElBQUlFLE9BQU87SUFFWCxJQUFJQyxJQUFJLFNBQVNBLEVBQUVQLE9BQU87UUFDeEIsT0FBT0EsV0FBV0EsUUFBUVEsaUJBQWlCLEdBQUcscUJBQXFCRixPQUFPLFdBQVdBLE9BQU8sZ0JBQWdCO0lBQzlHO0lBRUEsSUFBSUcsS0FBSztJQUNULElBQUlDLFFBQVE7SUFDWixJQUFJQyxLQUFLLENBQUMsZUFBZUQsUUFBUSxhQUFhQSxRQUFRLHFGQUFxRkEsUUFBUSxhQUFhRCxLQUFLLE9BQU9DLFFBQVEsb0hBQW9IQSxRQUFRLGNBQWNELEtBQUssVUFBVUMsUUFBUSxnSEFBZ0hBLFFBQVEsaUJBQWlCQSxRQUFRLFlBQVlELEtBQUssVUFBVUMsUUFBUSw4RkFBOEZBLFFBQVEsaUJBQWlCQSxRQUFRLFlBQVlELEtBQUssVUFBVUMsUUFBUSw4RkFBOEZBLFFBQVEsaUJBQWlCQSxRQUFRLFlBQVlELEtBQUssVUFBVUMsUUFBUSw4RkFBOEZBLFFBQVEsaUJBQWlCQSxRQUFRLFlBQVlELEtBQUssVUFBVUMsUUFBUSxzR0FBc0dBLFFBQVEsWUFBWUQsS0FBSyxVQUFVQyxRQUFRLG9MQUFtTCxFQUFHckUsT0FBTyxDQUFDLGdCQUFnQixJQUFJQSxPQUFPLENBQUMsT0FBTyxJQUFJdUUsSUFBSSxJQUFJLHdGQUF3RjtJQUVyOEMsSUFBSUMsV0FBVyxJQUFJQyxPQUFPLFNBQVNMLEtBQUssWUFBWUUsS0FBSztJQUN6RCxJQUFJSSxVQUFVLElBQUlELE9BQU8sTUFBTUwsS0FBSztJQUNwQyxJQUFJTyxVQUFVLElBQUlGLE9BQU8sTUFBTUgsS0FBSztJQUVwQyxJQUFJTSxLQUFLLFNBQVNBLEdBQUdqQixPQUFPO1FBQzFCLE9BQU9BLFdBQVdBLFFBQVFrQixLQUFLLEdBQUdMLFdBQVcsSUFBSUMsT0FBTyxRQUFRUCxFQUFFUCxXQUFXUyxLQUFLRixFQUFFUCxXQUFXLFVBQVVPLEVBQUVQLFdBQVdXLEtBQUtKLEVBQUVQLFdBQVcsS0FBSztJQUMvSTtJQUVBaUIsR0FBR1IsRUFBRSxHQUFHLFNBQVVULE9BQU87UUFDdkIsT0FBT0EsV0FBV0EsUUFBUWtCLEtBQUssR0FBR0gsVUFBVSxJQUFJRCxPQUFPLEtBQUtQLEVBQUVQLFdBQVdTLEtBQUtGLEVBQUVQLFVBQVU7SUFDNUY7SUFFQWlCLEdBQUdOLEVBQUUsR0FBRyxTQUFVWCxPQUFPO1FBQ3ZCLE9BQU9BLFdBQVdBLFFBQVFrQixLQUFLLEdBQUdGLFVBQVUsSUFBSUYsT0FBTyxLQUFLUCxFQUFFUCxXQUFXVyxLQUFLSixFQUFFUCxVQUFVO0lBQzVGO0lBRUEsSUFBSW1CLFdBQVc7SUFDZixJQUFJQyxPQUFPO0lBQ1gsSUFBSUMsT0FBT0osR0FBR1IsRUFBRSxHQUFHL0ksTUFBTTtJQUN6QixJQUFJNEosT0FBT0wsR0FBR04sRUFBRSxHQUFHakosTUFBTTtJQUN6QixJQUFJNkosT0FBTztJQUNYLElBQUlDLFNBQVM7SUFDYixJQUFJQyxNQUFNO0lBQ1YsSUFBSUMsT0FBTztJQUNYLElBQUl0QyxPQUFPO0lBQ1gsSUFBSXVDLFFBQVEsUUFBUVIsV0FBVyxhQUFhQyxPQUFPLGtCQUFrQkMsT0FBTyxNQUFNQyxPQUFPLE1BQU1DLE9BQU9DLFNBQVNDLE1BQU0sTUFBTUMsT0FBT3RDO0lBQ2xJZ0IsU0FBUyxJQUFJVSxPQUFPLFNBQVNhLFFBQVEsTUFBTTtJQUMzQyxPQUFPdkI7QUFDVDtBQUVBLG9CQUFvQixHQUVwQixJQUFJd0IsWUFBWTtJQUNkLHlCQUF5QjtJQUN6QkMsT0FBTztJQUNQLG1CQUFtQjtJQUNuQixzWkFBc1o7SUFDdFosU0FBUztJQUNULEtBQUs7SUFDTEMsS0FBSztBQUNQO0FBQ0EsSUFBSUMsUUFBUTtJQUNWQyxTQUFTLFNBQVNBLFFBQVF0SCxLQUFLO1FBQzdCLE9BQU9xSCxNQUFNRSxNQUFNLENBQUN2SCxVQUFVd0gsU0FBU3hILE9BQU8sUUFBUUE7SUFDeEQ7SUFDQSxTQUFTLFNBQVN5SCxNQUFNekgsS0FBSztRQUMzQixPQUFPcUgsTUFBTUUsTUFBTSxDQUFDdkgsVUFBVSxDQUFDcUgsTUFBTUMsT0FBTyxDQUFDdEg7SUFDL0M7SUFDQTBILE9BQU8sU0FBU0EsTUFBTTFILEtBQUs7UUFDekIsT0FBT3VCLE1BQU1hLE9BQU8sQ0FBQ3BDO0lBQ3ZCO0lBQ0EySCxRQUFRLFNBQVNBLE9BQU8zSCxLQUFLO1FBQzNCLElBQUlBLGlCQUFpQm9HLFFBQVE7WUFDM0IsT0FBTztRQUNUO1FBRUEsSUFBSTtZQUNGLE9BQU8sQ0FBQyxDQUFDLElBQUlBLE9BQU9wRztRQUN0QixFQUFFLE9BQU92QixHQUFHO1lBQ1YsT0FBTztRQUNUO0lBQ0Y7SUFDQW1KLE1BQU0sU0FBU0EsS0FBSzVILEtBQUs7UUFDdkIsT0FBTyxPQUFPQSxNQUFNNkgsT0FBTyxLQUFLLGNBQWMsT0FBTzdILE1BQU04SCxRQUFRLEtBQUssY0FBYyxPQUFPOUgsTUFBTStILE9BQU8sS0FBSyxjQUFjLENBQUNDLE1BQU1oSSxNQUFNNkgsT0FBTztJQUNuSjtJQUNBTixRQUFRLFNBQVNBLE9BQU92SCxLQUFLO1FBQzNCLElBQUlnSSxNQUFNaEksUUFBUTtZQUNoQixPQUFPO1FBQ1Q7UUFFQSxPQUFPLE9BQU9BLFVBQVU7SUFDMUI7SUFDQWlJLFFBQVEsU0FBU0EsT0FBT2pJLEtBQUs7UUFDM0IsT0FBTyxPQUFPQSxVQUFVLFlBQVksQ0FBQ3FILE1BQU1LLEtBQUssQ0FBQzFIO0lBQ25EO0lBQ0FrSSxRQUFRLFNBQVNBLE9BQU9sSSxLQUFLO1FBQzNCLE9BQU8sT0FBT0EsVUFBVTtJQUMxQjtJQUNBbUgsT0FBTyxTQUFTQSxNQUFNbkgsS0FBSztRQUN6QixPQUFPLE9BQU9BLFVBQVUsWUFBWUEsTUFBTWpELE1BQU0sSUFBSSxPQUFPLENBQUMsQ0FBQ2lELE1BQU1tSSxLQUFLLENBQUNqQixVQUFVQyxLQUFLO0lBQzFGO0lBQ0FpQixLQUFLLFNBQVNBLElBQUlwSSxLQUFLO1FBQ3JCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxNQUFNakQsTUFBTSxJQUFJLFFBQVEsQ0FBQyxDQUFDaUQsTUFBTW1JLEtBQUssQ0FBQ3hDO0lBQzVFO0lBQ0F5QixLQUFLLFNBQVNBLElBQUlwSCxLQUFLO1FBQ3JCLE9BQU8sT0FBT0EsVUFBVSxZQUFZLENBQUMsQ0FBQ0EsTUFBTW1JLEtBQUssQ0FBQ2pCLFVBQVVFLEdBQUc7SUFDakU7QUFDRjtBQUVBLElBQUlpQixTQUFTLFNBQVM1SCxLQUFLb0UsSUFBSSxFQUFFN0UsS0FBSyxFQUFFaEQsTUFBTSxFQUFFMEQsTUFBTSxFQUFFNEUsT0FBTztJQUM3RCxJQUFJVCxLQUFLUSxRQUFRLElBQUlyRixVQUFVTixXQUFXO1FBQ3hDMEYsV0FBV1AsTUFBTTdFLE9BQU9oRCxRQUFRMEQsUUFBUTRFO1FBQ3hDO0lBQ0Y7SUFFQSxJQUFJZ0QsU0FBUztRQUFDO1FBQVc7UUFBUztRQUFTO1FBQVU7UUFBVTtRQUFVO1FBQVM7UUFBVTtRQUFRO1FBQU87S0FBTTtJQUNqSCxJQUFJQyxXQUFXMUQsS0FBS3BFLElBQUk7SUFFeEIsSUFBSTZILE9BQU9oSixPQUFPLENBQUNpSixZQUFZLENBQUMsR0FBRztRQUNqQyxJQUFJLENBQUNsQixLQUFLLENBQUNrQixTQUFTLENBQUN2SSxRQUFRO1lBQzNCVSxPQUFPM0IsSUFBSSxDQUFDcUMsT0FBT2tFLFFBQVFDLFFBQVEsQ0FBQzhCLEtBQUssQ0FBQ2tCLFNBQVMsRUFBRTFELEtBQUtJLFNBQVMsRUFBRUosS0FBS3BFLElBQUk7UUFDaEYsRUFBRSx3QkFBd0I7SUFFNUIsT0FBTyxJQUFJOEgsWUFBWSxPQUFPdkksVUFBVTZFLEtBQUtwRSxJQUFJLEVBQUU7UUFDakRDLE9BQU8zQixJQUFJLENBQUNxQyxPQUFPa0UsUUFBUUMsUUFBUSxDQUFDOEIsS0FBSyxDQUFDa0IsU0FBUyxFQUFFMUQsS0FBS0ksU0FBUyxFQUFFSixLQUFLcEUsSUFBSTtJQUNoRjtBQUNGO0FBRUEsSUFBSStILFFBQVEsU0FBU0EsTUFBTTNELElBQUksRUFBRTdFLEtBQUssRUFBRWhELE1BQU0sRUFBRTBELE1BQU0sRUFBRTRFLE9BQU87SUFDN0QsSUFBSTdELE1BQU0sT0FBT29ELEtBQUtwRCxHQUFHLEtBQUs7SUFDOUIsSUFBSWdILE1BQU0sT0FBTzVELEtBQUs0RCxHQUFHLEtBQUs7SUFDOUIsSUFBSUMsTUFBTSxPQUFPN0QsS0FBSzZELEdBQUcsS0FBSyxVQUFVLDJEQUEyRDtJQUVuRyxJQUFJQyxXQUFXO0lBQ2YsSUFBSUMsTUFBTTVJO0lBQ1YsSUFBSS9DLE1BQU07SUFDVixJQUFJNEwsTUFBTSxPQUFPN0ksVUFBVTtJQUMzQixJQUFJMEIsTUFBTSxPQUFPMUIsVUFBVTtJQUMzQixJQUFJc0MsTUFBTWYsTUFBTWEsT0FBTyxDQUFDcEM7SUFFeEIsSUFBSTZJLEtBQUs7UUFDUDVMLE1BQU07SUFDUixPQUFPLElBQUl5RSxLQUFLO1FBQ2R6RSxNQUFNO0lBQ1IsT0FBTyxJQUFJcUYsS0FBSztRQUNkckYsTUFBTTtJQUNSLEVBQUUsK0RBQStEO0lBQ2pFLDBDQUEwQztJQUMxQyxtREFBbUQ7SUFHbkQsSUFBSSxDQUFDQSxLQUFLO1FBQ1IsT0FBTztJQUNUO0lBRUEsSUFBSXFGLEtBQUs7UUFDUHNHLE1BQU01SSxNQUFNakQsTUFBTTtJQUNwQjtJQUVBLElBQUkyRSxLQUFLO1FBQ1AsMERBQTBEO1FBQzFEa0gsTUFBTTVJLE1BQU0yQixPQUFPLENBQUNnSCxVQUFVLEtBQUs1TCxNQUFNO0lBQzNDO0lBRUEsSUFBSTBFLEtBQUs7UUFDUCxJQUFJbUgsUUFBUS9ELEtBQUtwRCxHQUFHLEVBQUU7WUFDcEJmLE9BQU8zQixJQUFJLENBQUNxQyxPQUFPa0UsUUFBUUMsUUFBUSxDQUFDdEksSUFBSSxDQUFDd0UsR0FBRyxFQUFFb0QsS0FBS0ksU0FBUyxFQUFFSixLQUFLcEQsR0FBRztRQUN4RTtJQUNGLE9BQU8sSUFBSWdILE9BQU8sQ0FBQ0MsT0FBT0UsTUFBTS9ELEtBQUs0RCxHQUFHLEVBQUU7UUFDeEMvSCxPQUFPM0IsSUFBSSxDQUFDcUMsT0FBT2tFLFFBQVFDLFFBQVEsQ0FBQ3RJLElBQUksQ0FBQ3dMLEdBQUcsRUFBRTVELEtBQUtJLFNBQVMsRUFBRUosS0FBSzRELEdBQUc7SUFDeEUsT0FBTyxJQUFJQyxPQUFPLENBQUNELE9BQU9HLE1BQU0vRCxLQUFLNkQsR0FBRyxFQUFFO1FBQ3hDaEksT0FBTzNCLElBQUksQ0FBQ3FDLE9BQU9rRSxRQUFRQyxRQUFRLENBQUN0SSxJQUFJLENBQUN5TCxHQUFHLEVBQUU3RCxLQUFLSSxTQUFTLEVBQUVKLEtBQUs2RCxHQUFHO0lBQ3hFLE9BQU8sSUFBSUQsT0FBT0MsT0FBUUUsQ0FBQUEsTUFBTS9ELEtBQUs0RCxHQUFHLElBQUlHLE1BQU0vRCxLQUFLNkQsR0FBRyxHQUFHO1FBQzNEaEksT0FBTzNCLElBQUksQ0FBQ3FDLE9BQU9rRSxRQUFRQyxRQUFRLENBQUN0SSxJQUFJLENBQUN1TCxLQUFLLEVBQUUzRCxLQUFLSSxTQUFTLEVBQUVKLEtBQUs0RCxHQUFHLEVBQUU1RCxLQUFLNkQsR0FBRztJQUNwRjtBQUNGO0FBRUEsSUFBSUksU0FBUztBQUViLElBQUlDLGVBQWUsU0FBUzlJLFdBQVc0RSxJQUFJLEVBQUU3RSxLQUFLLEVBQUVoRCxNQUFNLEVBQUUwRCxNQUFNLEVBQUU0RSxPQUFPO0lBQ3pFVCxJQUFJLENBQUNpRSxPQUFPLEdBQUd2SCxNQUFNYSxPQUFPLENBQUN5QyxJQUFJLENBQUNpRSxPQUFPLElBQUlqRSxJQUFJLENBQUNpRSxPQUFPLEdBQUcsRUFBRTtJQUU5RCxJQUFJakUsSUFBSSxDQUFDaUUsT0FBTyxDQUFDeEosT0FBTyxDQUFDVSxXQUFXLENBQUMsR0FBRztRQUN0Q1UsT0FBTzNCLElBQUksQ0FBQ3FDLE9BQU9rRSxRQUFRQyxRQUFRLENBQUN1RCxPQUFPLEVBQUVqRSxLQUFLSSxTQUFTLEVBQUVKLElBQUksQ0FBQ2lFLE9BQU8sQ0FBQ0UsSUFBSSxDQUFDO0lBQ2pGO0FBQ0Y7QUFFQSxJQUFJQyxZQUFZLFNBQVNDLFFBQVFyRSxJQUFJLEVBQUU3RSxLQUFLLEVBQUVoRCxNQUFNLEVBQUUwRCxNQUFNLEVBQUU0RSxPQUFPO0lBQ25FLElBQUlULEtBQUtxRSxPQUFPLEVBQUU7UUFDaEIsSUFBSXJFLEtBQUtxRSxPQUFPLFlBQVk5QyxRQUFRO1lBQ2xDLHlFQUF5RTtZQUN6RSxxRUFBcUU7WUFDckUsc0RBQXNEO1lBQ3REdkIsS0FBS3FFLE9BQU8sQ0FBQ0MsU0FBUyxHQUFHO1lBRXpCLElBQUksQ0FBQ3RFLEtBQUtxRSxPQUFPLENBQUN6RCxJQUFJLENBQUN6RixRQUFRO2dCQUM3QlUsT0FBTzNCLElBQUksQ0FBQ3FDLE9BQU9rRSxRQUFRQyxRQUFRLENBQUMyRCxPQUFPLENBQUNFLFFBQVEsRUFBRXZFLEtBQUtJLFNBQVMsRUFBRWpGLE9BQU82RSxLQUFLcUUsT0FBTztZQUMzRjtRQUNGLE9BQU8sSUFBSSxPQUFPckUsS0FBS3FFLE9BQU8sS0FBSyxVQUFVO1lBQzNDLElBQUlHLFdBQVcsSUFBSWpELE9BQU92QixLQUFLcUUsT0FBTztZQUV0QyxJQUFJLENBQUNHLFNBQVM1RCxJQUFJLENBQUN6RixRQUFRO2dCQUN6QlUsT0FBTzNCLElBQUksQ0FBQ3FDLE9BQU9rRSxRQUFRQyxRQUFRLENBQUMyRCxPQUFPLENBQUNFLFFBQVEsRUFBRXZFLEtBQUtJLFNBQVMsRUFBRWpGLE9BQU82RSxLQUFLcUUsT0FBTztZQUMzRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLElBQUlJLFFBQVE7SUFDVmpFLFVBQVVEO0lBQ1ZJLFlBQVlBO0lBQ1ovRSxNQUFNNEg7SUFDTkcsT0FBT0E7SUFDUCxRQUFRTztJQUNSRyxTQUFTRDtBQUNYO0FBRUEsSUFBSU0sU0FBUyxTQUFTQSxPQUFPMUUsSUFBSSxFQUFFN0UsS0FBSyxFQUFFd0MsUUFBUSxFQUFFeEYsTUFBTSxFQUFFc0ksT0FBTztJQUNqRSxJQUFJNUUsU0FBUyxFQUFFO0lBQ2YsSUFBSThJLFdBQVczRSxLQUFLUSxRQUFRLElBQUksQ0FBQ1IsS0FBS1EsUUFBUSxJQUFJckksT0FBT0csY0FBYyxDQUFDMEgsS0FBSzFELEtBQUs7SUFFbEYsSUFBSXFJLFVBQVU7UUFDWixJQUFJckgsYUFBYW5DLE9BQU8sYUFBYSxDQUFDNkUsS0FBS1EsUUFBUSxFQUFFO1lBQ25ELE9BQU83QztRQUNUO1FBRUE4RyxNQUFNakUsUUFBUSxDQUFDUixNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEUsU0FBUztRQUVyRCxJQUFJLENBQUNuRCxhQUFhbkMsT0FBTyxXQUFXO1lBQ2xDc0osTUFBTTdJLElBQUksQ0FBQ29FLE1BQU03RSxPQUFPaEQsUUFBUTBELFFBQVE0RTtZQUN4Q2dFLE1BQU1kLEtBQUssQ0FBQzNELE1BQU03RSxPQUFPaEQsUUFBUTBELFFBQVE0RTtZQUN6Q2dFLE1BQU1KLE9BQU8sQ0FBQ3JFLE1BQU03RSxPQUFPaEQsUUFBUTBELFFBQVE0RTtZQUUzQyxJQUFJVCxLQUFLVyxVQUFVLEtBQUssTUFBTTtnQkFDNUI4RCxNQUFNOUQsVUFBVSxDQUFDWCxNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEU7WUFDaEQ7UUFDRjtJQUNGO0lBRUE5QyxTQUFTOUI7QUFDWDtBQUVBLElBQUl3SCxTQUFTLFNBQVNBLE9BQU9yRCxJQUFJLEVBQUU3RSxLQUFLLEVBQUV3QyxRQUFRLEVBQUV4RixNQUFNLEVBQUVzSSxPQUFPO0lBQ2pFLElBQUk1RSxTQUFTLEVBQUU7SUFDZixJQUFJOEksV0FBVzNFLEtBQUtRLFFBQVEsSUFBSSxDQUFDUixLQUFLUSxRQUFRLElBQUlySSxPQUFPRyxjQUFjLENBQUMwSCxLQUFLMUQsS0FBSztJQUVsRixJQUFJcUksVUFBVTtRQUNaLElBQUlySCxhQUFhbkMsVUFBVSxDQUFDNkUsS0FBS1EsUUFBUSxFQUFFO1lBQ3pDLE9BQU83QztRQUNUO1FBRUE4RyxNQUFNakUsUUFBUSxDQUFDUixNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEU7UUFFNUMsSUFBSXRGLFVBQVVOLFdBQVc7WUFDdkI0SixNQUFNN0ksSUFBSSxDQUFDb0UsTUFBTTdFLE9BQU9oRCxRQUFRMEQsUUFBUTRFO1FBQzFDO0lBQ0Y7SUFFQTlDLFNBQVM5QjtBQUNYO0FBRUEsSUFBSTZHLFNBQVMsU0FBU0EsT0FBTzFDLElBQUksRUFBRTdFLEtBQUssRUFBRXdDLFFBQVEsRUFBRXhGLE1BQU0sRUFBRXNJLE9BQU87SUFDakUsSUFBSTVFLFNBQVMsRUFBRTtJQUNmLElBQUk4SSxXQUFXM0UsS0FBS1EsUUFBUSxJQUFJLENBQUNSLEtBQUtRLFFBQVEsSUFBSXJJLE9BQU9HLGNBQWMsQ0FBQzBILEtBQUsxRCxLQUFLO0lBRWxGLElBQUlxSSxVQUFVO1FBQ1osSUFBSXhKLFVBQVUsSUFBSTtZQUNoQkEsUUFBUU47UUFDVjtRQUVBLElBQUl5QyxhQUFhbkMsVUFBVSxDQUFDNkUsS0FBS1EsUUFBUSxFQUFFO1lBQ3pDLE9BQU83QztRQUNUO1FBRUE4RyxNQUFNakUsUUFBUSxDQUFDUixNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEU7UUFFNUMsSUFBSXRGLFVBQVVOLFdBQVc7WUFDdkI0SixNQUFNN0ksSUFBSSxDQUFDb0UsTUFBTTdFLE9BQU9oRCxRQUFRMEQsUUFBUTRFO1lBQ3hDZ0UsTUFBTWQsS0FBSyxDQUFDM0QsTUFBTTdFLE9BQU9oRCxRQUFRMEQsUUFBUTRFO1FBQzNDO0lBQ0Y7SUFFQTlDLFNBQVM5QjtBQUNYO0FBRUEsSUFBSStJLFdBQVcsU0FBU0EsU0FBUzVFLElBQUksRUFBRTdFLEtBQUssRUFBRXdDLFFBQVEsRUFBRXhGLE1BQU0sRUFBRXNJLE9BQU87SUFDckUsSUFBSTVFLFNBQVMsRUFBRTtJQUNmLElBQUk4SSxXQUFXM0UsS0FBS1EsUUFBUSxJQUFJLENBQUNSLEtBQUtRLFFBQVEsSUFBSXJJLE9BQU9HLGNBQWMsQ0FBQzBILEtBQUsxRCxLQUFLO0lBRWxGLElBQUlxSSxVQUFVO1FBQ1osSUFBSXJILGFBQWFuQyxVQUFVLENBQUM2RSxLQUFLUSxRQUFRLEVBQUU7WUFDekMsT0FBTzdDO1FBQ1Q7UUFFQThHLE1BQU1qRSxRQUFRLENBQUNSLE1BQU03RSxPQUFPaEQsUUFBUTBELFFBQVE0RTtRQUU1QyxJQUFJdEYsVUFBVU4sV0FBVztZQUN2QjRKLE1BQU03SSxJQUFJLENBQUNvRSxNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEU7UUFDMUM7SUFDRjtJQUVBOUMsU0FBUzlCO0FBQ1g7QUFFQSxJQUFJaUgsU0FBUyxTQUFTQSxPQUFPOUMsSUFBSSxFQUFFN0UsS0FBSyxFQUFFd0MsUUFBUSxFQUFFeEYsTUFBTSxFQUFFc0ksT0FBTztJQUNqRSxJQUFJNUUsU0FBUyxFQUFFO0lBQ2YsSUFBSThJLFdBQVczRSxLQUFLUSxRQUFRLElBQUksQ0FBQ1IsS0FBS1EsUUFBUSxJQUFJckksT0FBT0csY0FBYyxDQUFDMEgsS0FBSzFELEtBQUs7SUFFbEYsSUFBSXFJLFVBQVU7UUFDWixJQUFJckgsYUFBYW5DLFVBQVUsQ0FBQzZFLEtBQUtRLFFBQVEsRUFBRTtZQUN6QyxPQUFPN0M7UUFDVDtRQUVBOEcsTUFBTWpFLFFBQVEsQ0FBQ1IsTUFBTTdFLE9BQU9oRCxRQUFRMEQsUUFBUTRFO1FBRTVDLElBQUksQ0FBQ25ELGFBQWFuQyxRQUFRO1lBQ3hCc0osTUFBTTdJLElBQUksQ0FBQ29FLE1BQU03RSxPQUFPaEQsUUFBUTBELFFBQVE0RTtRQUMxQztJQUNGO0lBRUE5QyxTQUFTOUI7QUFDWDtBQUVBLElBQUk0RyxVQUFVLFNBQVNBLFFBQVF6QyxJQUFJLEVBQUU3RSxLQUFLLEVBQUV3QyxRQUFRLEVBQUV4RixNQUFNLEVBQUVzSSxPQUFPO0lBQ25FLElBQUk1RSxTQUFTLEVBQUU7SUFDZixJQUFJOEksV0FBVzNFLEtBQUtRLFFBQVEsSUFBSSxDQUFDUixLQUFLUSxRQUFRLElBQUlySSxPQUFPRyxjQUFjLENBQUMwSCxLQUFLMUQsS0FBSztJQUVsRixJQUFJcUksVUFBVTtRQUNaLElBQUlySCxhQUFhbkMsVUFBVSxDQUFDNkUsS0FBS1EsUUFBUSxFQUFFO1lBQ3pDLE9BQU83QztRQUNUO1FBRUE4RyxNQUFNakUsUUFBUSxDQUFDUixNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEU7UUFFNUMsSUFBSXRGLFVBQVVOLFdBQVc7WUFDdkI0SixNQUFNN0ksSUFBSSxDQUFDb0UsTUFBTTdFLE9BQU9oRCxRQUFRMEQsUUFBUTRFO1lBQ3hDZ0UsTUFBTWQsS0FBSyxDQUFDM0QsTUFBTTdFLE9BQU9oRCxRQUFRMEQsUUFBUTRFO1FBQzNDO0lBQ0Y7SUFFQTlDLFNBQVM5QjtBQUNYO0FBRUEsSUFBSWdKLFVBQVUsU0FBU0EsUUFBUTdFLElBQUksRUFBRTdFLEtBQUssRUFBRXdDLFFBQVEsRUFBRXhGLE1BQU0sRUFBRXNJLE9BQU87SUFDbkUsSUFBSTVFLFNBQVMsRUFBRTtJQUNmLElBQUk4SSxXQUFXM0UsS0FBS1EsUUFBUSxJQUFJLENBQUNSLEtBQUtRLFFBQVEsSUFBSXJJLE9BQU9HLGNBQWMsQ0FBQzBILEtBQUsxRCxLQUFLO0lBRWxGLElBQUlxSSxVQUFVO1FBQ1osSUFBSXJILGFBQWFuQyxVQUFVLENBQUM2RSxLQUFLUSxRQUFRLEVBQUU7WUFDekMsT0FBTzdDO1FBQ1Q7UUFFQThHLE1BQU1qRSxRQUFRLENBQUNSLE1BQU03RSxPQUFPaEQsUUFBUTBELFFBQVE0RTtRQUU1QyxJQUFJdEYsVUFBVU4sV0FBVztZQUN2QjRKLE1BQU03SSxJQUFJLENBQUNvRSxNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEU7WUFDeENnRSxNQUFNZCxLQUFLLENBQUMzRCxNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEU7UUFDM0M7SUFDRjtJQUVBOUMsU0FBUzlCO0FBQ1g7QUFFQSxJQUFJZ0gsUUFBUSxTQUFTQSxNQUFNN0MsSUFBSSxFQUFFN0UsS0FBSyxFQUFFd0MsUUFBUSxFQUFFeEYsTUFBTSxFQUFFc0ksT0FBTztJQUMvRCxJQUFJNUUsU0FBUyxFQUFFO0lBQ2YsSUFBSThJLFdBQVczRSxLQUFLUSxRQUFRLElBQUksQ0FBQ1IsS0FBS1EsUUFBUSxJQUFJckksT0FBT0csY0FBYyxDQUFDMEgsS0FBSzFELEtBQUs7SUFFbEYsSUFBSXFJLFVBQVU7UUFDWixJQUFJLENBQUN4SixVQUFVTixhQUFhTSxVQUFVLElBQUcsS0FBTSxDQUFDNkUsS0FBS1EsUUFBUSxFQUFFO1lBQzdELE9BQU83QztRQUNUO1FBRUE4RyxNQUFNakUsUUFBUSxDQUFDUixNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEUsU0FBUztRQUVyRCxJQUFJdEYsVUFBVU4sYUFBYU0sVUFBVSxNQUFNO1lBQ3pDc0osTUFBTTdJLElBQUksQ0FBQ29FLE1BQU03RSxPQUFPaEQsUUFBUTBELFFBQVE0RTtZQUN4Q2dFLE1BQU1kLEtBQUssQ0FBQzNELE1BQU03RSxPQUFPaEQsUUFBUTBELFFBQVE0RTtRQUMzQztJQUNGO0lBRUE5QyxTQUFTOUI7QUFDWDtBQUVBLElBQUl1SCxTQUFTLFNBQVNBLE9BQU9wRCxJQUFJLEVBQUU3RSxLQUFLLEVBQUV3QyxRQUFRLEVBQUV4RixNQUFNLEVBQUVzSSxPQUFPO0lBQ2pFLElBQUk1RSxTQUFTLEVBQUU7SUFDZixJQUFJOEksV0FBVzNFLEtBQUtRLFFBQVEsSUFBSSxDQUFDUixLQUFLUSxRQUFRLElBQUlySSxPQUFPRyxjQUFjLENBQUMwSCxLQUFLMUQsS0FBSztJQUVsRixJQUFJcUksVUFBVTtRQUNaLElBQUlySCxhQUFhbkMsVUFBVSxDQUFDNkUsS0FBS1EsUUFBUSxFQUFFO1lBQ3pDLE9BQU83QztRQUNUO1FBRUE4RyxNQUFNakUsUUFBUSxDQUFDUixNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEU7UUFFNUMsSUFBSXRGLFVBQVVOLFdBQVc7WUFDdkI0SixNQUFNN0ksSUFBSSxDQUFDb0UsTUFBTTdFLE9BQU9oRCxRQUFRMEQsUUFBUTRFO1FBQzFDO0lBQ0Y7SUFFQTlDLFNBQVM5QjtBQUNYO0FBRUEsSUFBSWlKLE9BQU87QUFFWCxJQUFJMUosYUFBYSxTQUFTQSxXQUFXNEUsSUFBSSxFQUFFN0UsS0FBSyxFQUFFd0MsUUFBUSxFQUFFeEYsTUFBTSxFQUFFc0ksT0FBTztJQUN6RSxJQUFJNUUsU0FBUyxFQUFFO0lBQ2YsSUFBSThJLFdBQVczRSxLQUFLUSxRQUFRLElBQUksQ0FBQ1IsS0FBS1EsUUFBUSxJQUFJckksT0FBT0csY0FBYyxDQUFDMEgsS0FBSzFELEtBQUs7SUFFbEYsSUFBSXFJLFVBQVU7UUFDWixJQUFJckgsYUFBYW5DLFVBQVUsQ0FBQzZFLEtBQUtRLFFBQVEsRUFBRTtZQUN6QyxPQUFPN0M7UUFDVDtRQUVBOEcsTUFBTWpFLFFBQVEsQ0FBQ1IsTUFBTTdFLE9BQU9oRCxRQUFRMEQsUUFBUTRFO1FBRTVDLElBQUl0RixVQUFVTixXQUFXO1lBQ3ZCNEosS0FBSyxDQUFDSyxLQUFLLENBQUM5RSxNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEU7UUFDM0M7SUFDRjtJQUVBOUMsU0FBUzlCO0FBQ1g7QUFFQSxJQUFJd0ksVUFBVSxTQUFTQSxRQUFRckUsSUFBSSxFQUFFN0UsS0FBSyxFQUFFd0MsUUFBUSxFQUFFeEYsTUFBTSxFQUFFc0ksT0FBTztJQUNuRSxJQUFJNUUsU0FBUyxFQUFFO0lBQ2YsSUFBSThJLFdBQVczRSxLQUFLUSxRQUFRLElBQUksQ0FBQ1IsS0FBS1EsUUFBUSxJQUFJckksT0FBT0csY0FBYyxDQUFDMEgsS0FBSzFELEtBQUs7SUFFbEYsSUFBSXFJLFVBQVU7UUFDWixJQUFJckgsYUFBYW5DLE9BQU8sYUFBYSxDQUFDNkUsS0FBS1EsUUFBUSxFQUFFO1lBQ25ELE9BQU83QztRQUNUO1FBRUE4RyxNQUFNakUsUUFBUSxDQUFDUixNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEU7UUFFNUMsSUFBSSxDQUFDbkQsYUFBYW5DLE9BQU8sV0FBVztZQUNsQ3NKLE1BQU1KLE9BQU8sQ0FBQ3JFLE1BQU03RSxPQUFPaEQsUUFBUTBELFFBQVE0RTtRQUM3QztJQUNGO0lBRUE5QyxTQUFTOUI7QUFDWDtBQUVBLElBQUlrSCxPQUFPLFNBQVNBLEtBQUsvQyxJQUFJLEVBQUU3RSxLQUFLLEVBQUV3QyxRQUFRLEVBQUV4RixNQUFNLEVBQUVzSSxPQUFPO0lBQzdELCtDQUErQztJQUMvQyxJQUFJNUUsU0FBUyxFQUFFO0lBQ2YsSUFBSThJLFdBQVczRSxLQUFLUSxRQUFRLElBQUksQ0FBQ1IsS0FBS1EsUUFBUSxJQUFJckksT0FBT0csY0FBYyxDQUFDMEgsS0FBSzFELEtBQUssR0FBRyw4Q0FBOEM7SUFFbkksSUFBSXFJLFVBQVU7UUFDWixJQUFJckgsYUFBYW5DLE9BQU8sV0FBVyxDQUFDNkUsS0FBS1EsUUFBUSxFQUFFO1lBQ2pELE9BQU83QztRQUNUO1FBRUE4RyxNQUFNakUsUUFBUSxDQUFDUixNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEU7UUFFNUMsSUFBSSxDQUFDbkQsYUFBYW5DLE9BQU8sU0FBUztZQUNoQyxJQUFJNEo7WUFFSixJQUFJNUosaUJBQWlCNkosTUFBTTtnQkFDekJELGFBQWE1SjtZQUNmLE9BQU87Z0JBQ0w0SixhQUFhLElBQUlDLEtBQUs3SjtZQUN4QjtZQUVBc0osTUFBTTdJLElBQUksQ0FBQ29FLE1BQU0rRSxZQUFZNU0sUUFBUTBELFFBQVE0RTtZQUU3QyxJQUFJc0UsWUFBWTtnQkFDZE4sTUFBTWQsS0FBSyxDQUFDM0QsTUFBTStFLFdBQVcvQixPQUFPLElBQUk3SyxRQUFRMEQsUUFBUTRFO1lBQzFEO1FBQ0Y7SUFDRjtJQUVBOUMsU0FBUzlCO0FBQ1g7QUFFQSxJQUFJMkUsV0FBVyxTQUFTQSxTQUFTUixJQUFJLEVBQUU3RSxLQUFLLEVBQUV3QyxRQUFRLEVBQUV4RixNQUFNLEVBQUVzSSxPQUFPO0lBQ3JFLElBQUk1RSxTQUFTLEVBQUU7SUFDZixJQUFJRCxPQUFPYyxNQUFNYSxPQUFPLENBQUNwQyxTQUFTLFVBQVUsT0FBT0E7SUFDbkRzSixNQUFNakUsUUFBUSxDQUFDUixNQUFNN0UsT0FBT2hELFFBQVEwRCxRQUFRNEUsU0FBUzdFO0lBQ3JEK0IsU0FBUzlCO0FBQ1g7QUFFQSxJQUFJRCxPQUFPLFNBQVNBLEtBQUtvRSxJQUFJLEVBQUU3RSxLQUFLLEVBQUV3QyxRQUFRLEVBQUV4RixNQUFNLEVBQUVzSSxPQUFPO0lBQzdELElBQUlpRCxXQUFXMUQsS0FBS3BFLElBQUk7SUFDeEIsSUFBSUMsU0FBUyxFQUFFO0lBQ2YsSUFBSThJLFdBQVczRSxLQUFLUSxRQUFRLElBQUksQ0FBQ1IsS0FBS1EsUUFBUSxJQUFJckksT0FBT0csY0FBYyxDQUFDMEgsS0FBSzFELEtBQUs7SUFFbEYsSUFBSXFJLFVBQVU7UUFDWixJQUFJckgsYUFBYW5DLE9BQU91SSxhQUFhLENBQUMxRCxLQUFLUSxRQUFRLEVBQUU7WUFDbkQsT0FBTzdDO1FBQ1Q7UUFFQThHLE1BQU1qRSxRQUFRLENBQUNSLE1BQU03RSxPQUFPaEQsUUFBUTBELFFBQVE0RSxTQUFTaUQ7UUFFckQsSUFBSSxDQUFDcEcsYUFBYW5DLE9BQU91SSxXQUFXO1lBQ2xDZSxNQUFNN0ksSUFBSSxDQUFDb0UsTUFBTTdFLE9BQU9oRCxRQUFRMEQsUUFBUTRFO1FBQzFDO0lBQ0Y7SUFFQTlDLFNBQVM5QjtBQUNYO0FBRUEsSUFBSW9KLE1BQU0sU0FBU0EsSUFBSWpGLElBQUksRUFBRTdFLEtBQUssRUFBRXdDLFFBQVEsRUFBRXhGLE1BQU0sRUFBRXNJLE9BQU87SUFDM0QsSUFBSTVFLFNBQVMsRUFBRTtJQUNmLElBQUk4SSxXQUFXM0UsS0FBS1EsUUFBUSxJQUFJLENBQUNSLEtBQUtRLFFBQVEsSUFBSXJJLE9BQU9HLGNBQWMsQ0FBQzBILEtBQUsxRCxLQUFLO0lBRWxGLElBQUlxSSxVQUFVO1FBQ1osSUFBSXJILGFBQWFuQyxVQUFVLENBQUM2RSxLQUFLUSxRQUFRLEVBQUU7WUFDekMsT0FBTzdDO1FBQ1Q7UUFFQThHLE1BQU1qRSxRQUFRLENBQUNSLE1BQU03RSxPQUFPaEQsUUFBUTBELFFBQVE0RTtJQUM5QztJQUVBOUMsU0FBUzlCO0FBQ1g7QUFFQSxJQUFJcUosYUFBYTtJQUNmUixRQUFRQTtJQUNSckIsUUFBUUE7SUFDUlgsUUFBUUE7SUFDUixXQUFXa0M7SUFDWDlCLFFBQVFBO0lBQ1JMLFNBQVNBO0lBQ1QsU0FBU29DO0lBQ1RoQyxPQUFPQTtJQUNQTyxRQUFRQTtJQUNSLFFBQVFoSTtJQUNSaUosU0FBU0E7SUFDVHRCLE1BQU1BO0lBQ05RLEtBQUszSDtJQUNMMkcsS0FBSzNHO0lBQ0wwRyxPQUFPMUc7SUFDUDRFLFVBQVVBO0lBQ1Z5RSxLQUFLQTtBQUNQO0FBRUEsU0FBU0U7SUFDUCxPQUFPO1FBQ0wsV0FBVztRQUNYM0UsVUFBVTtRQUNWLFFBQVE7UUFDUkcsWUFBWTtRQUNab0MsTUFBTTtZQUNKeEcsUUFBUTtZQUNSNkksT0FBTztZQUNQQyxTQUFTO1FBQ1g7UUFDQTdDLE9BQU87WUFDTGtDLFFBQVE7WUFDUnJCLFFBQVE7WUFDUlIsT0FBTztZQUNQTyxRQUFRO1lBQ1JWLFFBQVE7WUFDUkssTUFBTTtZQUNOLFdBQVc7WUFDWE4sU0FBUztZQUNULFNBQVM7WUFDVEssUUFBUTtZQUNSUixPQUFPO1lBQ1BpQixLQUFLO1lBQ0xoQixLQUFLO1FBQ1A7UUFDQW1DLFFBQVE7WUFDTjlILEtBQUs7WUFDTGdILEtBQUs7WUFDTEMsS0FBSztZQUNMRixPQUFPO1FBQ1Q7UUFDQWpCLFFBQVE7WUFDTjlGLEtBQUs7WUFDTGdILEtBQUs7WUFDTEMsS0FBSztZQUNMRixPQUFPO1FBQ1Q7UUFDQWQsT0FBTztZQUNMakcsS0FBSztZQUNMZ0gsS0FBSztZQUNMQyxLQUFLO1lBQ0xGLE9BQU87UUFDVDtRQUNBVSxTQUFTO1lBQ1BFLFVBQVU7UUFDWjtRQUNBZSxPQUFPLFNBQVNBO1lBQ2QsSUFBSUMsU0FBU3JJLEtBQUtrSSxLQUFLLENBQUNsSSxLQUFLQyxTQUFTLENBQUMsSUFBSTtZQUMzQ29JLE9BQU9ELEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUs7WUFDekIsT0FBT0M7UUFDVDtJQUNGO0FBQ0Y7QUFDQSxJQUFJN0UsV0FBV3lFO0FBRWY7Ozs7O0NBS0MsR0FFRCxJQUFJSyxTQUFTLFdBQVcsR0FBRTtJQUN4Qiw2REFBNkQ7SUFDN0QsNkRBQTZEO0lBQzdELFNBQVNBLE9BQU9DLFVBQVU7UUFDeEIsSUFBSSxDQUFDaEIsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDaUIsU0FBUyxHQUFHaEY7UUFDakIsSUFBSSxDQUFDaUYsTUFBTSxDQUFDRjtJQUNkO0lBRUEsSUFBSUcsU0FBU0osT0FBT25OLFNBQVM7SUFFN0J1TixPQUFPRCxNQUFNLEdBQUcsU0FBU0EsT0FBT2xCLEtBQUs7UUFDbkMsSUFBSTlGLFFBQVEsSUFBSTtRQUVoQixJQUFJLENBQUM4RixPQUFPO1lBQ1YsTUFBTSxJQUFJN0YsTUFBTTtRQUNsQjtRQUVBLElBQUksT0FBTzZGLFVBQVUsWUFBWS9ILE1BQU1hLE9BQU8sQ0FBQ2tILFFBQVE7WUFDckQsTUFBTSxJQUFJN0YsTUFBTTtRQUNsQjtRQUVBLElBQUksQ0FBQzZGLEtBQUssR0FBRyxDQUFDO1FBQ2Q3TSxPQUFPMkcsSUFBSSxDQUFDa0csT0FBT3JJLE9BQU8sQ0FBQyxTQUFVeUosSUFBSTtZQUN2QyxJQUFJQyxPQUFPckIsS0FBSyxDQUFDb0IsS0FBSztZQUN0QmxILE1BQU04RixLQUFLLENBQUNvQixLQUFLLEdBQUduSixNQUFNYSxPQUFPLENBQUN1SSxRQUFRQSxPQUFPO2dCQUFDQTthQUFLO1FBQ3pEO0lBQ0Y7SUFFQUYsT0FBT2xGLFFBQVEsR0FBRyxTQUFTQSxTQUFTZ0YsU0FBUztRQUMzQyxJQUFJQSxXQUFXO1lBQ2IsSUFBSSxDQUFDQSxTQUFTLEdBQUdyRixVQUFVOEUsZUFBZU87UUFDNUM7UUFFQSxPQUFPLElBQUksQ0FBQ0EsU0FBUztJQUN2QjtJQUVBRSxPQUFPakIsUUFBUSxHQUFHLFNBQVNBLFNBQVNvQixPQUFPLEVBQUUvTSxDQUFDLEVBQUVnTixFQUFFO1FBQ2hELElBQUlDLFNBQVMsSUFBSTtRQUVqQixJQUFJak4sTUFBTSxLQUFLLEdBQUc7WUFDaEJBLElBQUksQ0FBQztRQUNQO1FBRUEsSUFBSWdOLE9BQU8sS0FBSyxHQUFHO1lBQ2pCQSxLQUFLLFNBQVNBLE1BQU07UUFDdEI7UUFFQSxJQUFJN04sU0FBUzROO1FBQ2IsSUFBSXRGLFVBQVV6SDtRQUNkLElBQUkyRSxXQUFXcUk7UUFFZixJQUFJLE9BQU92RixZQUFZLFlBQVk7WUFDakM5QyxXQUFXOEM7WUFDWEEsVUFBVSxDQUFDO1FBQ2I7UUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDZ0UsS0FBSyxJQUFJN00sT0FBTzJHLElBQUksQ0FBQyxJQUFJLENBQUNrRyxLQUFLLEVBQUV2TSxNQUFNLEtBQUssR0FBRztZQUN2RCxJQUFJeUYsVUFBVTtnQkFDWkEsU0FBUyxNQUFNeEY7WUFDakI7WUFFQSxPQUFPOEcsUUFBUUMsT0FBTyxDQUFDL0c7UUFDekI7UUFFQSxTQUFTK04sU0FBU3RJLE9BQU87WUFDdkIsSUFBSS9CLFNBQVMsRUFBRTtZQUNmLElBQUlNLFNBQVMsQ0FBQztZQUVkLFNBQVNnSyxJQUFJdk0sQ0FBQztnQkFDWixJQUFJOEMsTUFBTWEsT0FBTyxDQUFDM0QsSUFBSTtvQkFDcEIsSUFBSXdNO29CQUVKdkssU0FBUyxDQUFDdUssVUFBVXZLLE1BQUssRUFBR3dLLE1BQU0sQ0FBQzdOLEtBQUssQ0FBQzROLFNBQVN4TTtnQkFDcEQsT0FBTztvQkFDTGlDLE9BQU8zQixJQUFJLENBQUNOO2dCQUNkO1lBQ0Y7WUFFQSxJQUFLLElBQUk1QixJQUFJLEdBQUdBLElBQUk0RixRQUFRMUYsTUFBTSxFQUFFRixJQUFLO2dCQUN2Q21PLElBQUl2SSxPQUFPLENBQUM1RixFQUFFO1lBQ2hCO1lBRUEsSUFBSSxDQUFDNkQsT0FBTzNELE1BQU0sRUFBRTtnQkFDbEJ5RixTQUFTLE1BQU14RjtZQUNqQixPQUFPO2dCQUNMZ0UsU0FBU0QsbUJBQW1CTDtnQkFDNUI4QixTQUFTOUIsUUFBUU07WUFDbkI7UUFDRjtRQUVBLElBQUlzRSxRQUFRQyxRQUFRLEVBQUU7WUFDcEIsSUFBSTRGLGFBQWEsSUFBSSxDQUFDNUYsUUFBUTtZQUU5QixJQUFJNEYsZUFBZTVGLFVBQVU7Z0JBQzNCNEYsYUFBYW5CO1lBQ2Y7WUFFQTlFLFVBQVVpRyxZQUFZN0YsUUFBUUMsUUFBUTtZQUN0Q0QsUUFBUUMsUUFBUSxHQUFHNEY7UUFDckIsT0FBTztZQUNMN0YsUUFBUUMsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtRQUNsQztRQUVBLElBQUk2RixTQUFTLENBQUM7UUFDZCxJQUFJaEksT0FBT2tDLFFBQVFsQyxJQUFJLElBQUkzRyxPQUFPMkcsSUFBSSxDQUFDLElBQUksQ0FBQ2tHLEtBQUs7UUFDakRsRyxLQUFLbkMsT0FBTyxDQUFDLFNBQVVvSyxDQUFDO1lBQ3RCLElBQUkvSSxNQUFNd0ksT0FBT3hCLEtBQUssQ0FBQytCLEVBQUU7WUFDekIsSUFBSXJMLFFBQVFoRCxNQUFNLENBQUNxTyxFQUFFO1lBQ3JCL0ksSUFBSXJCLE9BQU8sQ0FBQyxTQUFVcUssQ0FBQztnQkFDckIsSUFBSXpHLE9BQU95RztnQkFFWCxJQUFJLE9BQU96RyxLQUFLMEcsU0FBUyxLQUFLLFlBQVk7b0JBQ3hDLElBQUl2TyxXQUFXNE4sU0FBUzt3QkFDdEI1TixTQUFTUixTQUFTLENBQUMsR0FBR1E7b0JBQ3hCO29CQUVBZ0QsUUFBUWhELE1BQU0sQ0FBQ3FPLEVBQUUsR0FBR3hHLEtBQUswRyxTQUFTLENBQUN2TDtnQkFDckM7Z0JBRUEsSUFBSSxPQUFPNkUsU0FBUyxZQUFZO29CQUM5QkEsT0FBTzt3QkFDTDJHLFdBQVczRztvQkFDYjtnQkFDRixPQUFPO29CQUNMQSxPQUFPckksU0FBUyxDQUFDLEdBQUdxSTtnQkFDdEIsRUFBRSxtREFBbUQ7Z0JBR3JEQSxLQUFLMkcsU0FBUyxHQUFHVixPQUFPVyxtQkFBbUIsQ0FBQzVHO2dCQUU1QyxJQUFJLENBQUNBLEtBQUsyRyxTQUFTLEVBQUU7b0JBQ25CO2dCQUNGO2dCQUVBM0csS0FBSzFELEtBQUssR0FBR2tLO2dCQUNieEcsS0FBS0ksU0FBUyxHQUFHSixLQUFLSSxTQUFTLElBQUlvRztnQkFDbkN4RyxLQUFLcEUsSUFBSSxHQUFHcUssT0FBT1ksT0FBTyxDQUFDN0c7Z0JBQzNCdUcsTUFBTSxDQUFDQyxFQUFFLEdBQUdELE1BQU0sQ0FBQ0MsRUFBRSxJQUFJLEVBQUU7Z0JBQzNCRCxNQUFNLENBQUNDLEVBQUUsQ0FBQ3RNLElBQUksQ0FBQztvQkFDYjhGLE1BQU1BO29CQUNON0UsT0FBT0E7b0JBQ1BoRCxRQUFRQTtvQkFDUm1FLE9BQU9rSztnQkFDVDtZQUNGO1FBQ0Y7UUFDQSxJQUFJTSxjQUFjLENBQUM7UUFDbkIsT0FBT2pJLFNBQVMwSCxRQUFROUYsU0FBUyxTQUFVc0csSUFBSSxFQUFFQyxJQUFJO1lBQ25ELElBQUloSCxPQUFPK0csS0FBSy9HLElBQUk7WUFDcEIsSUFBSWlILE9BQU8sQ0FBQ2pILEtBQUtwRSxJQUFJLEtBQUssWUFBWW9FLEtBQUtwRSxJQUFJLEtBQUssT0FBTSxLQUFPLFFBQU9vRSxLQUFLN0QsTUFBTSxLQUFLLFlBQVksT0FBTzZELEtBQUtrSCxZQUFZLEtBQUssUUFBTztZQUN4SUQsT0FBT0EsUUFBU2pILENBQUFBLEtBQUtRLFFBQVEsSUFBSSxDQUFDUixLQUFLUSxRQUFRLElBQUl1RyxLQUFLNUwsS0FBSztZQUM3RDZFLEtBQUsxRCxLQUFLLEdBQUd5SyxLQUFLekssS0FBSztZQUV2QixTQUFTNkssYUFBYS9PLEdBQUcsRUFBRWdQLE1BQU07Z0JBQy9CLE9BQU96UCxTQUFTLENBQUMsR0FBR3lQLFFBQVE7b0JBQzFCaEgsV0FBV0osS0FBS0ksU0FBUyxHQUFHLE1BQU1oSTtvQkFDbEMrSCxZQUFZSCxLQUFLRyxVQUFVLEdBQUcsRUFBRSxDQUFDa0csTUFBTSxDQUFDckcsS0FBS0csVUFBVSxFQUFFO3dCQUFDL0g7cUJBQUksSUFBSTt3QkFBQ0E7cUJBQUk7Z0JBQ3pFO1lBQ0Y7WUFFQSxTQUFTaVAsR0FBR3pOLENBQUM7Z0JBQ1gsSUFBSUEsTUFBTSxLQUFLLEdBQUc7b0JBQ2hCQSxJQUFJLEVBQUU7Z0JBQ1I7Z0JBRUEsSUFBSTBOLFlBQVk1SyxNQUFNYSxPQUFPLENBQUMzRCxLQUFLQSxJQUFJO29CQUFDQTtpQkFBRTtnQkFFMUMsSUFBSSxDQUFDNkcsUUFBUThHLGVBQWUsSUFBSUQsVUFBVXBQLE1BQU0sRUFBRTtvQkFDaERzTixPQUFPaEssT0FBTyxDQUFDLG9CQUFvQjhMO2dCQUNyQztnQkFFQSxJQUFJQSxVQUFVcFAsTUFBTSxJQUFJOEgsS0FBS0wsT0FBTyxLQUFLOUUsV0FBVztvQkFDbER5TSxZQUFZLEVBQUUsQ0FBQ2pCLE1BQU0sQ0FBQ3JHLEtBQUtMLE9BQU87Z0JBQ3BDLEVBQUUsa0JBQWtCO2dCQUdwQixJQUFJNkgsZUFBZUYsVUFBVUcsR0FBRyxDQUFDMUgsZ0JBQWdCQyxNQUFNN0g7Z0JBRXZELElBQUlzSSxRQUFRMUIsS0FBSyxJQUFJeUksYUFBYXRQLE1BQU0sRUFBRTtvQkFDeEM0TyxXQUFXLENBQUM5RyxLQUFLMUQsS0FBSyxDQUFDLEdBQUc7b0JBQzFCLE9BQU8wSyxLQUFLUTtnQkFDZDtnQkFFQSxJQUFJLENBQUNQLE1BQU07b0JBQ1RELEtBQUtRO2dCQUNQLE9BQU87b0JBQ0wsNENBQTRDO29CQUM1QyxrREFBa0Q7b0JBQ2xELFlBQVk7b0JBQ1osSUFBSXhILEtBQUtRLFFBQVEsSUFBSSxDQUFDdUcsS0FBSzVMLEtBQUssRUFBRTt3QkFDaEMsSUFBSTZFLEtBQUtMLE9BQU8sS0FBSzlFLFdBQVc7NEJBQzlCMk0sZUFBZSxFQUFFLENBQUNuQixNQUFNLENBQUNyRyxLQUFLTCxPQUFPLEVBQUU4SCxHQUFHLENBQUMxSCxnQkFBZ0JDLE1BQU03SDt3QkFDbkUsT0FBTyxJQUFJc0ksUUFBUXBFLEtBQUssRUFBRTs0QkFDeEJtTCxlQUFlO2dDQUFDL0csUUFBUXBFLEtBQUssQ0FBQzJELE1BQU16RCxPQUFPa0UsUUFBUUMsUUFBUSxDQUFDRixRQUFRLEVBQUVSLEtBQUsxRCxLQUFLOzZCQUFHO3dCQUNyRjt3QkFFQSxPQUFPMEssS0FBS1E7b0JBQ2Q7b0JBRUEsSUFBSUUsZUFBZSxDQUFDO29CQUVwQixJQUFJMUgsS0FBS2tILFlBQVksRUFBRTt3QkFDckJ0UCxPQUFPMkcsSUFBSSxDQUFDd0ksS0FBSzVMLEtBQUssRUFBRXNNLEdBQUcsQ0FBQyxTQUFVclAsR0FBRzs0QkFDdkNzUCxZQUFZLENBQUN0UCxJQUFJLEdBQUc0SCxLQUFLa0gsWUFBWTt3QkFDdkM7b0JBQ0Y7b0JBRUFRLGVBQWUvUCxTQUFTLENBQUMsR0FBRytQLGNBQWNYLEtBQUsvRyxJQUFJLENBQUM3RCxNQUFNO29CQUMxRCxJQUFJd0wsb0JBQW9CLENBQUM7b0JBQ3pCL1AsT0FBTzJHLElBQUksQ0FBQ21KLGNBQWN0TCxPQUFPLENBQUMsU0FBVUUsS0FBSzt3QkFDL0MsSUFBSXNMLGNBQWNGLFlBQVksQ0FBQ3BMLE1BQU07d0JBQ3JDLElBQUl1TCxrQkFBa0JuTCxNQUFNYSxPQUFPLENBQUNxSyxlQUFlQSxjQUFjOzRCQUFDQTt5QkFBWTt3QkFDOUVELGlCQUFpQixDQUFDckwsTUFBTSxHQUFHdUwsZ0JBQWdCSixHQUFHLENBQUNOLGFBQWFyUCxJQUFJLENBQUMsTUFBTXdFO29CQUN6RTtvQkFDQSxJQUFJOEssU0FBUyxJQUFJNUIsT0FBT21DO29CQUN4QlAsT0FBTzFHLFFBQVEsQ0FBQ0QsUUFBUUMsUUFBUTtvQkFFaEMsSUFBSXFHLEtBQUsvRyxJQUFJLENBQUNTLE9BQU8sRUFBRTt3QkFDckJzRyxLQUFLL0csSUFBSSxDQUFDUyxPQUFPLENBQUNDLFFBQVEsR0FBR0QsUUFBUUMsUUFBUTt3QkFDN0NxRyxLQUFLL0csSUFBSSxDQUFDUyxPQUFPLENBQUNwRSxLQUFLLEdBQUdvRSxRQUFRcEUsS0FBSztvQkFDekM7b0JBRUErSyxPQUFPekMsUUFBUSxDQUFDb0MsS0FBSzVMLEtBQUssRUFBRTRMLEtBQUsvRyxJQUFJLENBQUNTLE9BQU8sSUFBSUEsU0FBUyxTQUFVcUgsSUFBSTt3QkFDdEUsSUFBSUMsY0FBYyxFQUFFO3dCQUVwQixJQUFJUCxnQkFBZ0JBLGFBQWF0UCxNQUFNLEVBQUU7NEJBQ3ZDNlAsWUFBWTdOLElBQUksQ0FBQzFCLEtBQUssQ0FBQ3VQLGFBQWFQO3dCQUN0Qzt3QkFFQSxJQUFJTSxRQUFRQSxLQUFLNVAsTUFBTSxFQUFFOzRCQUN2QjZQLFlBQVk3TixJQUFJLENBQUMxQixLQUFLLENBQUN1UCxhQUFhRDt3QkFDdEM7d0JBRUFkLEtBQUtlLFlBQVk3UCxNQUFNLEdBQUc2UCxjQUFjO29CQUMxQztnQkFDRjtZQUNGO1lBRUEsSUFBSUM7WUFFSixJQUFJaEksS0FBS2lJLGNBQWMsRUFBRTtnQkFDdkJELE1BQU1oSSxLQUFLaUksY0FBYyxDQUFDakksTUFBTStHLEtBQUs1TCxLQUFLLEVBQUVrTSxJQUFJTixLQUFLNU8sTUFBTSxFQUFFc0k7WUFDL0QsT0FBTyxJQUFJVCxLQUFLMkcsU0FBUyxFQUFFO2dCQUN6QixJQUFJO29CQUNGcUIsTUFBTWhJLEtBQUsyRyxTQUFTLENBQUMzRyxNQUFNK0csS0FBSzVMLEtBQUssRUFBRWtNLElBQUlOLEtBQUs1TyxNQUFNLEVBQUVzSTtnQkFDMUQsRUFBRSxPQUFPcEUsT0FBTztvQkFDZFAsUUFBUU8sS0FBSyxJQUFJLE9BQU8sS0FBSyxJQUFJUCxRQUFRTyxLQUFLLENBQUNBLFFBQVEsMEJBQTBCO29CQUVqRixJQUFJLENBQUNvRSxRQUFReUgsc0JBQXNCLEVBQUU7d0JBQ25DQyxXQUFXOzRCQUNULE1BQU05TDt3QkFDUixHQUFHO29CQUNMO29CQUVBZ0wsR0FBR2hMLE1BQU1zRCxPQUFPO2dCQUNsQjtnQkFFQSxJQUFJcUksUUFBUSxNQUFNO29CQUNoQlg7Z0JBQ0YsT0FBTyxJQUFJVyxRQUFRLE9BQU87b0JBQ3hCWCxHQUFHLE9BQU9ySCxLQUFLTCxPQUFPLEtBQUssYUFBYUssS0FBS0wsT0FBTyxDQUFDSyxLQUFLSSxTQUFTLElBQUlKLEtBQUsxRCxLQUFLLElBQUkwRCxLQUFLTCxPQUFPLElBQUksQ0FBQ0ssS0FBS0ksU0FBUyxJQUFJSixLQUFLMUQsS0FBSyxJQUFJO2dCQUN4SSxPQUFPLElBQUkwTCxlQUFldEwsT0FBTztvQkFDL0IySyxHQUFHVztnQkFDTCxPQUFPLElBQUlBLGVBQWVwSixPQUFPO29CQUMvQnlJLEdBQUdXLElBQUlySSxPQUFPO2dCQUNoQjtZQUNGO1lBRUEsSUFBSXFJLE9BQU9BLElBQUlJLElBQUksRUFBRTtnQkFDbkJKLElBQUlJLElBQUksQ0FBQztvQkFDUCxPQUFPZjtnQkFDVCxHQUFHLFNBQVV6TixDQUFDO29CQUNaLE9BQU95TixHQUFHek47Z0JBQ1o7WUFDRjtRQUNGLEdBQUcsU0FBVWdFLE9BQU87WUFDbEJzSSxTQUFTdEk7UUFDWCxHQUFHekY7SUFDTDtJQUVBeU4sT0FBT2lCLE9BQU8sR0FBRyxTQUFTQSxRQUFRN0csSUFBSTtRQUNwQyxJQUFJQSxLQUFLcEUsSUFBSSxLQUFLZixhQUFhbUYsS0FBS3FFLE9BQU8sWUFBWTlDLFFBQVE7WUFDN0R2QixLQUFLcEUsSUFBSSxHQUFHO1FBQ2Q7UUFFQSxJQUFJLE9BQU9vRSxLQUFLMkcsU0FBUyxLQUFLLGNBQWMzRyxLQUFLcEUsSUFBSSxJQUFJLENBQUNzSixXQUFXNU0sY0FBYyxDQUFDMEgsS0FBS3BFLElBQUksR0FBRztZQUM5RixNQUFNLElBQUlnRCxNQUFNckMsT0FBTyx3QkFBd0J5RCxLQUFLcEUsSUFBSTtRQUMxRDtRQUVBLE9BQU9vRSxLQUFLcEUsSUFBSSxJQUFJO0lBQ3RCO0lBRUFnSyxPQUFPZ0IsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQW9CNUcsSUFBSTtRQUM1RCxJQUFJLE9BQU9BLEtBQUsyRyxTQUFTLEtBQUssWUFBWTtZQUN4QyxPQUFPM0csS0FBSzJHLFNBQVM7UUFDdkI7UUFFQSxJQUFJcEksT0FBTzNHLE9BQU8yRyxJQUFJLENBQUN5QjtRQUN2QixJQUFJcUksZUFBZTlKLEtBQUs5RCxPQUFPLENBQUM7UUFFaEMsSUFBSTROLGlCQUFpQixDQUFDLEdBQUc7WUFDdkI5SixLQUFLK0osTUFBTSxDQUFDRCxjQUFjO1FBQzVCO1FBRUEsSUFBSTlKLEtBQUtyRyxNQUFNLEtBQUssS0FBS3FHLElBQUksQ0FBQyxFQUFFLEtBQUssWUFBWTtZQUMvQyxPQUFPMkcsV0FBVzFFLFFBQVE7UUFDNUI7UUFFQSxPQUFPMEUsVUFBVSxDQUFDLElBQUksQ0FBQzJCLE9BQU8sQ0FBQzdHLE1BQU0sSUFBSW5GO0lBQzNDO0lBRUEsT0FBTzJLO0FBQ1Q7QUFFQUEsT0FBTytDLFFBQVEsR0FBRyxTQUFTQSxTQUFTM00sSUFBSSxFQUFFK0ssU0FBUztJQUNqRCxJQUFJLE9BQU9BLGNBQWMsWUFBWTtRQUNuQyxNQUFNLElBQUkvSCxNQUFNO0lBQ2xCO0lBRUFzRyxVQUFVLENBQUN0SixLQUFLLEdBQUcrSztBQUNyQjtBQUVBbkIsT0FBT2hLLE9BQU8sR0FBR0E7QUFDakJnSyxPQUFPOUUsUUFBUSxHQUFHQTtBQUNsQjhFLE9BQU9OLFVBQVUsR0FBR0E7QUFFUyxDQUM3QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9scHBtcy8uL25vZGVfbW9kdWxlcy9hc3luYy12YWxpZGF0b3IvZGlzdC13ZWIvaW5kZXguanM/ZmUzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcblxuICBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdC5iaW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfTtcblxuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xudmFyIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKCkge307IC8vIGRvbid0IHByaW50IHdhcm5pbmcgbWVzc2FnZSB3aGVuIGluIHByb2R1Y3Rpb24gZW52IG9yIG5vZGUgcnVudGltZVxuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyh0eXBlLCBlcnJvcnMpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybiAmJiB0eXBlb2YgQVNZTkNfVkFMSURBVE9SX05PX1dBUk5JTkcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoZXJyb3JzLmV2ZXJ5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZSA9PT0gJ3N0cmluZyc7XG4gICAgICB9KSkge1xuICAgICAgICBjb25zb2xlLndhcm4odHlwZSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGaWVsZHNFcnJvcihlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMgfHwgIWVycm9ycy5sZW5ndGgpIHJldHVybiBudWxsO1xuICB2YXIgZmllbGRzID0ge307XG4gIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHZhciBmaWVsZCA9IGVycm9yLmZpZWxkO1xuICAgIGZpZWxkc1tmaWVsZF0gPSBmaWVsZHNbZmllbGRdIHx8IFtdO1xuICAgIGZpZWxkc1tmaWVsZF0ucHVzaChlcnJvcik7XG4gIH0pO1xuICByZXR1cm4gZmllbGRzO1xufVxuZnVuY3Rpb24gZm9ybWF0KHRlbXBsYXRlKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdGVtcGxhdGUuYXBwbHkobnVsbCwgYXJncyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzdHIgPSB0ZW1wbGF0ZS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh4ID09PSAnJSUnKSB7XG4gICAgICAgIHJldHVybiAnJSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID49IGxlbikge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh4KSB7XG4gICAgICAgIGNhc2UgJyVzJzpcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG5cbiAgICAgICAgY2FzZSAnJWQnOlxuICAgICAgICAgIHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcblxuICAgICAgICBjYXNlICclaic6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIHRlbXBsYXRlO1xufVxuXG5mdW5jdGlvbiBpc05hdGl2ZVN0cmluZ1R5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ3VybCcgfHwgdHlwZSA9PT0gJ2hleCcgfHwgdHlwZSA9PT0gJ2VtYWlsJyB8fCB0eXBlID09PSAnZGF0ZScgfHwgdHlwZSA9PT0gJ3BhdHRlcm4nO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5VmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnYXJyYXknICYmIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICF2YWx1ZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpc05hdGl2ZVN0cmluZ1R5cGUodHlwZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhdmFsdWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXN5bmNQYXJhbGxlbEFycmF5KGFyciwgZnVuYywgY2FsbGJhY2spIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIHRvdGFsID0gMDtcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gY291bnQoZXJyb3JzKSB7XG4gICAgcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIGVycm9ycyB8fCBbXSk7XG4gICAgdG90YWwrKztcblxuICAgIGlmICh0b3RhbCA9PT0gYXJyTGVuZ3RoKSB7XG4gICAgICBjYWxsYmFjayhyZXN1bHRzKTtcbiAgICB9XG4gIH1cblxuICBhcnIuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgIGZ1bmMoYSwgY291bnQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYXN5bmNTZXJpYWxBcnJheShhcnIsIGZ1bmMsIGNhbGxiYWNrKSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIG5leHQoZXJyb3JzKSB7XG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMubGVuZ3RoKSB7XG4gICAgICBjYWxsYmFjayhlcnJvcnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbCA9IGluZGV4O1xuICAgIGluZGV4ID0gaW5kZXggKyAxO1xuXG4gICAgaWYgKG9yaWdpbmFsIDwgYXJyTGVuZ3RoKSB7XG4gICAgICBmdW5jKGFycltvcmlnaW5hbF0sIG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhbXSk7XG4gICAgfVxuICB9XG5cbiAgbmV4dChbXSk7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5PYmpBcnIob2JqQXJyKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgT2JqZWN0LmtleXMob2JqQXJyKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0LnB1c2guYXBwbHkocmV0LCBvYmpBcnJba10gfHwgW10pO1xuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cblxudmFyIEFzeW5jVmFsaWRhdGlvbkVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoQXN5bmNWYWxpZGF0aW9uRXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gQXN5bmNWYWxpZGF0aW9uRXJyb3IoZXJyb3JzLCBmaWVsZHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9FcnJvci5jYWxsKHRoaXMsICdBc3luYyBWYWxpZGF0aW9uIEVycm9yJykgfHwgdGhpcztcbiAgICBfdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgX3RoaXMuZmllbGRzID0gZmllbGRzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBBc3luY1ZhbGlkYXRpb25FcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5mdW5jdGlvbiBhc3luY01hcChvYmpBcnIsIG9wdGlvbiwgZnVuYywgY2FsbGJhY2ssIHNvdXJjZSkge1xuICBpZiAob3B0aW9uLmZpcnN0KSB7XG4gICAgdmFyIF9wZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiBuZXh0KGVycm9ycykge1xuICAgICAgICBjYWxsYmFjayhlcnJvcnMpO1xuICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA/IHJlamVjdChuZXcgQXN5bmNWYWxpZGF0aW9uRXJyb3IoZXJyb3JzLCBjb252ZXJ0RmllbGRzRXJyb3IoZXJyb3JzKSkpIDogcmVzb2x2ZShzb3VyY2UpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGZsYXR0ZW5BcnIgPSBmbGF0dGVuT2JqQXJyKG9iakFycik7XG4gICAgICBhc3luY1NlcmlhbEFycmF5KGZsYXR0ZW5BcnIsIGZ1bmMsIG5leHQpO1xuICAgIH0pO1xuXG4gICAgX3BlbmRpbmdbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3BlbmRpbmc7XG4gIH1cblxuICB2YXIgZmlyc3RGaWVsZHMgPSBvcHRpb24uZmlyc3RGaWVsZHMgPT09IHRydWUgPyBPYmplY3Qua2V5cyhvYmpBcnIpIDogb3B0aW9uLmZpcnN0RmllbGRzIHx8IFtdO1xuICB2YXIgb2JqQXJyS2V5cyA9IE9iamVjdC5rZXlzKG9iakFycik7XG4gIHZhciBvYmpBcnJMZW5ndGggPSBvYmpBcnJLZXlzLmxlbmd0aDtcbiAgdmFyIHRvdGFsID0gMDtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIG5leHQgPSBmdW5jdGlvbiBuZXh0KGVycm9ycykge1xuICAgICAgcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIGVycm9ycyk7XG4gICAgICB0b3RhbCsrO1xuXG4gICAgICBpZiAodG90YWwgPT09IG9iakFyckxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjayhyZXN1bHRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMubGVuZ3RoID8gcmVqZWN0KG5ldyBBc3luY1ZhbGlkYXRpb25FcnJvcihyZXN1bHRzLCBjb252ZXJ0RmllbGRzRXJyb3IocmVzdWx0cykpKSA6IHJlc29sdmUoc291cmNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFvYmpBcnJLZXlzLmxlbmd0aCkge1xuICAgICAgY2FsbGJhY2socmVzdWx0cyk7XG4gICAgICByZXNvbHZlKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgb2JqQXJyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBhcnIgPSBvYmpBcnJba2V5XTtcblxuICAgICAgaWYgKGZpcnN0RmllbGRzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgYXN5bmNTZXJpYWxBcnJheShhcnIsIGZ1bmMsIG5leHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXN5bmNQYXJhbGxlbEFycmF5KGFyciwgZnVuYywgbmV4dCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBwZW5kaW5nW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG4gIHJldHVybiBwZW5kaW5nO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yT2JqKG9iaikge1xuICByZXR1cm4gISEob2JqICYmIG9iai5tZXNzYWdlICE9PSB1bmRlZmluZWQpO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSwgcGF0aCkge1xuICB2YXIgdiA9IHZhbHVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh2ID09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgdiA9IHZbcGF0aFtpXV07XG4gIH1cblxuICByZXR1cm4gdjtcbn1cblxuZnVuY3Rpb24gY29tcGxlbWVudEVycm9yKHJ1bGUsIHNvdXJjZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKG9lKSB7XG4gICAgdmFyIGZpZWxkVmFsdWU7XG5cbiAgICBpZiAocnVsZS5mdWxsRmllbGRzKSB7XG4gICAgICBmaWVsZFZhbHVlID0gZ2V0VmFsdWUoc291cmNlLCBydWxlLmZ1bGxGaWVsZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWVsZFZhbHVlID0gc291cmNlW29lLmZpZWxkIHx8IHJ1bGUuZnVsbEZpZWxkXTtcbiAgICB9XG5cbiAgICBpZiAoaXNFcnJvck9iaihvZSkpIHtcbiAgICAgIG9lLmZpZWxkID0gb2UuZmllbGQgfHwgcnVsZS5mdWxsRmllbGQ7XG4gICAgICBvZS5maWVsZFZhbHVlID0gZmllbGRWYWx1ZTtcbiAgICAgIHJldHVybiBvZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogdHlwZW9mIG9lID09PSAnZnVuY3Rpb24nID8gb2UoKSA6IG9lLFxuICAgICAgZmllbGRWYWx1ZTogZmllbGRWYWx1ZSxcbiAgICAgIGZpZWxkOiBvZS5maWVsZCB8fCBydWxlLmZ1bGxGaWVsZFxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBkZWVwTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSkge1xuICAgIGZvciAodmFyIHMgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtzXTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0W3NdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRhcmdldFtzXSA9IF9leHRlbmRzKHt9LCB0YXJnZXRbc10sIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRbc10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciByZXF1aXJlZCQxID0gZnVuY3Rpb24gcmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zLCB0eXBlKSB7XG4gIGlmIChydWxlLnJlcXVpcmVkICYmICghc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpIHx8IGlzRW1wdHlWYWx1ZSh2YWx1ZSwgdHlwZSB8fCBydWxlLnR5cGUpKSkge1xuICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzLnJlcXVpcmVkLCBydWxlLmZ1bGxGaWVsZCkpO1xuICB9XG59O1xuXG4vKipcbiAqICBSdWxlIGZvciB2YWxpZGF0aW5nIHdoaXRlc3BhY2UuXG4gKlxuICogIEBwYXJhbSBydWxlIFRoZSB2YWxpZGF0aW9uIHJ1bGUuXG4gKiAgQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgZmllbGQgb24gdGhlIHNvdXJjZSBvYmplY3QuXG4gKiAgQHBhcmFtIHNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBiZWluZyB2YWxpZGF0ZWQuXG4gKiAgQHBhcmFtIGVycm9ycyBBbiBhcnJheSBvZiBlcnJvcnMgdGhhdCB0aGlzIHJ1bGUgbWF5IGFkZFxuICogIHZhbGlkYXRpb24gZXJyb3JzIHRvLlxuICogIEBwYXJhbSBvcHRpb25zIFRoZSB2YWxpZGF0aW9uIG9wdGlvbnMuXG4gKiAgQHBhcmFtIG9wdGlvbnMubWVzc2FnZXMgVGhlIHZhbGlkYXRpb24gbWVzc2FnZXMuXG4gKi9cblxudmFyIHdoaXRlc3BhY2UgPSBmdW5jdGlvbiB3aGl0ZXNwYWNlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucykge1xuICBpZiAoL15cXHMrJC8udGVzdCh2YWx1ZSkgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXMud2hpdGVzcGFjZSwgcnVsZS5mdWxsRmllbGQpKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tldnZhL3VybC1yZWdleC9ibG9iL21hc3Rlci9pbmRleC5qc1xudmFyIHVybFJlZztcbnZhciBnZXRVcmxSZWdleCA9IChmdW5jdGlvbiAoKSB7XG4gIGlmICh1cmxSZWcpIHtcbiAgICByZXR1cm4gdXJsUmVnO1xuICB9XG5cbiAgdmFyIHdvcmQgPSAnW2EtZkEtRlxcXFxkOl0nO1xuXG4gIHZhciBiID0gZnVuY3Rpb24gYihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlQm91bmRhcmllcyA/IFwiKD86KD88PVxcXFxzfF4pKD89XCIgKyB3b3JkICsgXCIpfCg/PD1cIiArIHdvcmQgKyBcIikoPz1cXFxcc3wkKSlcIiA6ICcnO1xuICB9O1xuXG4gIHZhciB2NCA9ICcoPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKD86XFxcXC4oPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKXszfSc7XG4gIHZhciB2NnNlZyA9ICdbYS1mQS1GXFxcXGRdezEsNH0nO1xuICB2YXIgdjYgPSAoXCJcXG4oPzpcXG4oPzpcIiArIHY2c2VnICsgXCI6KXs3fSg/OlwiICsgdjZzZWcgKyBcInw6KXwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxOjI6Mzo0OjU6Njo3OjogIDE6MjozOjQ6NTo2Ojc6OFxcbig/OlwiICsgdjZzZWcgKyBcIjopezZ9KD86XCIgKyB2NCArIFwifDpcIiArIHY2c2VnICsgXCJ8Oil8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxOjI6Mzo0OjU6Njo6ICAgIDE6MjozOjQ6NTo2Ojo4ICAgMToyOjM6NDo1OjY6OjggIDE6MjozOjQ6NTo2OjoxLjIuMy40XFxuKD86XCIgKyB2NnNlZyArIFwiOil7NX0oPzo6XCIgKyB2NCArIFwifCg/OjpcIiArIHY2c2VnICsgXCIpezEsMn18Oil8ICAgICAgICAgICAgICAgICAgIC8vIDE6MjozOjQ6NTo6ICAgICAgMToyOjM6NDo1Ojo3OjggICAxOjI6Mzo0OjU6OjggICAgMToyOjM6NDo1Ojo3OjEuMi4zLjRcXG4oPzpcIiArIHY2c2VnICsgXCI6KXs0fSg/Oig/OjpcIiArIHY2c2VnICsgXCIpezAsMX06XCIgKyB2NCArIFwifCg/OjpcIiArIHY2c2VnICsgXCIpezEsM318Oil8IC8vIDE6MjozOjQ6OiAgICAgICAgMToyOjM6NDo6Njo3OjggICAxOjI6Mzo0Ojo4ICAgICAgMToyOjM6NDo6Njo3OjEuMi4zLjRcXG4oPzpcIiArIHY2c2VnICsgXCI6KXszfSg/Oig/OjpcIiArIHY2c2VnICsgXCIpezAsMn06XCIgKyB2NCArIFwifCg/OjpcIiArIHY2c2VnICsgXCIpezEsNH18Oil8IC8vIDE6MjozOjogICAgICAgICAgMToyOjM6OjU6Njo3OjggICAxOjI6Mzo6OCAgICAgICAgMToyOjM6OjU6Njo3OjEuMi4zLjRcXG4oPzpcIiArIHY2c2VnICsgXCI6KXsyfSg/Oig/OjpcIiArIHY2c2VnICsgXCIpezAsM306XCIgKyB2NCArIFwifCg/OjpcIiArIHY2c2VnICsgXCIpezEsNX18Oil8IC8vIDE6Mjo6ICAgICAgICAgICAgMToyOjo0OjU6Njo3OjggICAxOjI6OjggICAgICAgICAgMToyOjo0OjU6Njo3OjEuMi4zLjRcXG4oPzpcIiArIHY2c2VnICsgXCI6KXsxfSg/Oig/OjpcIiArIHY2c2VnICsgXCIpezAsNH06XCIgKyB2NCArIFwifCg/OjpcIiArIHY2c2VnICsgXCIpezEsNn18Oil8IC8vIDE6OiAgICAgICAgICAgICAgMTo6Mzo0OjU6Njo3OjggICAxOjo4ICAgICAgICAgICAgMTo6Mzo0OjU6Njo3OjEuMi4zLjRcXG4oPzo6KD86KD86OlwiICsgdjZzZWcgKyBcIil7MCw1fTpcIiArIHY0ICsgXCJ8KD86OlwiICsgdjZzZWcgKyBcIil7MSw3fXw6KSkgICAgICAgICAgICAgLy8gOjoyOjM6NDo1OjY6Nzo4ICA6OjI6Mzo0OjU6Njo3OjggIDo6OCAgICAgICAgICAgICA6OjEuMi4zLjRcXG4pKD86JVswLTlhLXpBLVpdezEsfSk/ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJWV0aDAgICAgICAgICAgICAlMVxcblwiKS5yZXBsYWNlKC9cXHMqXFwvXFwvLiokL2dtLCAnJykucmVwbGFjZSgvXFxuL2csICcnKS50cmltKCk7IC8vIFByZS1jb21waWxlIG9ubHkgdGhlIGV4YWN0IHJlZ2V4ZXMgYmVjYXVzZSBhZGRpbmcgYSBnbG9iYWwgZmxhZyBtYWtlIHJlZ2V4ZXMgc3RhdGVmdWxcblxuICB2YXIgdjQ2RXhhY3QgPSBuZXcgUmVnRXhwKFwiKD86XlwiICsgdjQgKyBcIiQpfCg/Ol5cIiArIHY2ICsgXCIkKVwiKTtcbiAgdmFyIHY0ZXhhY3QgPSBuZXcgUmVnRXhwKFwiXlwiICsgdjQgKyBcIiRcIik7XG4gIHZhciB2NmV4YWN0ID0gbmV3IFJlZ0V4cChcIl5cIiArIHY2ICsgXCIkXCIpO1xuXG4gIHZhciBpcCA9IGZ1bmN0aW9uIGlwKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmV4YWN0ID8gdjQ2RXhhY3QgOiBuZXcgUmVnRXhwKFwiKD86XCIgKyBiKG9wdGlvbnMpICsgdjQgKyBiKG9wdGlvbnMpICsgXCIpfCg/OlwiICsgYihvcHRpb25zKSArIHY2ICsgYihvcHRpb25zKSArIFwiKVwiLCAnZycpO1xuICB9O1xuXG4gIGlwLnY0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmV4YWN0ID8gdjRleGFjdCA6IG5ldyBSZWdFeHAoXCJcIiArIGIob3B0aW9ucykgKyB2NCArIGIob3B0aW9ucyksICdnJyk7XG4gIH07XG5cbiAgaXAudjYgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuZXhhY3QgPyB2NmV4YWN0IDogbmV3IFJlZ0V4cChcIlwiICsgYihvcHRpb25zKSArIHY2ICsgYihvcHRpb25zKSwgJ2cnKTtcbiAgfTtcblxuICB2YXIgcHJvdG9jb2wgPSBcIig/Oig/OlthLXpdKzopPy8vKVwiO1xuICB2YXIgYXV0aCA9ICcoPzpcXFxcUysoPzo6XFxcXFMqKT9AKT8nO1xuICB2YXIgaXB2NCA9IGlwLnY0KCkuc291cmNlO1xuICB2YXIgaXB2NiA9IGlwLnY2KCkuc291cmNlO1xuICB2YXIgaG9zdCA9IFwiKD86KD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldWy1fXSopKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspXCI7XG4gIHZhciBkb21haW4gPSBcIig/OlxcXFwuKD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldLSopKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspKlwiO1xuICB2YXIgdGxkID0gXCIoPzpcXFxcLig/OlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmXXsyLH0pKVwiO1xuICB2YXIgcG9ydCA9ICcoPzo6XFxcXGR7Miw1fSk/JztcbiAgdmFyIHBhdGggPSAnKD86Wy8/I11bXlxcXFxzXCJdKik/JztcbiAgdmFyIHJlZ2V4ID0gXCIoPzpcIiArIHByb3RvY29sICsgXCJ8d3d3XFxcXC4pXCIgKyBhdXRoICsgXCIoPzpsb2NhbGhvc3R8XCIgKyBpcHY0ICsgXCJ8XCIgKyBpcHY2ICsgXCJ8XCIgKyBob3N0ICsgZG9tYWluICsgdGxkICsgXCIpXCIgKyBwb3J0ICsgcGF0aDtcbiAgdXJsUmVnID0gbmV3IFJlZ0V4cChcIig/Ol5cIiArIHJlZ2V4ICsgXCIkKVwiLCAnaScpO1xuICByZXR1cm4gdXJsUmVnO1xufSk7XG5cbi8qIGVzbGludCBtYXgtbGVuOjAgKi9cblxudmFyIHBhdHRlcm4kMiA9IHtcbiAgLy8gaHR0cDovL2VtYWlscmVnZXguY29tL1xuICBlbWFpbDogL14oKFtePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XSl8KChbYS16QS1aXFwtMC05XFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXStcXC4pK1thLXpBLVpcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdezIsfSkpJC8sXG4gIC8vIHVybDogbmV3IFJlZ0V4cChcbiAgLy8gICAnXig/IW1haWx0bzopKD86KD86aHR0cHxodHRwc3xmdHApOi8vfC8vKSg/OlxcXFxTKyg/OjpcXFxcUyopP0ApPyg/Oig/Oig/OlsxLTldXFxcXGQ/fDFcXFxcZFxcXFxkfDJbMDFdXFxcXGR8MjJbMC0zXSkoPzpcXFxcLig/OjE/XFxcXGR7MSwyfXwyWzAtNF1cXFxcZHwyNVswLTVdKSl7Mn0oPzpcXFxcLig/OlswLTldXFxcXGQ/fDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0rLSopKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspKD86XFxcXC4oPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0rLSopKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspKig/OlxcXFwuKD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmZdezIsfSkpKXxsb2NhbGhvc3QpKD86OlxcXFxkezIsNX0pPyg/OigvfFxcXFw/fCMpW15cXFxcc10qKT8kJyxcbiAgLy8gICAnaScsXG4gIC8vICksXG4gIGhleDogL14jPyhbYS1mMC05XXs2fXxbYS1mMC05XXszfSkkL2lcbn07XG52YXIgdHlwZXMgPSB7XG4gIGludGVnZXI6IGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZXMubnVtYmVyKHZhbHVlKSAmJiBwYXJzZUludCh2YWx1ZSwgMTApID09PSB2YWx1ZTtcbiAgfSxcbiAgXCJmbG9hdFwiOiBmdW5jdGlvbiBmbG9hdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlcy5udW1iZXIodmFsdWUpICYmICF0eXBlcy5pbnRlZ2VyKHZhbHVlKTtcbiAgfSxcbiAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9LFxuICByZWdleHA6IGZ1bmN0aW9uIHJlZ2V4cCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAhIW5ldyBSZWdFeHAodmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIGRhdGU6IGZ1bmN0aW9uIGRhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLmdldFRpbWUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmdldE1vbnRoID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5nZXRZZWFyID09PSAnZnVuY3Rpb24nICYmICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpO1xuICB9LFxuICBudW1iZXI6IGZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhdHlwZXMuYXJyYXkodmFsdWUpO1xuICB9LFxuICBtZXRob2Q6IGZ1bmN0aW9uIG1ldGhvZCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gIH0sXG4gIGVtYWlsOiBmdW5jdGlvbiBlbWFpbCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA8PSAzMjAgJiYgISF2YWx1ZS5tYXRjaChwYXR0ZXJuJDIuZW1haWwpO1xuICB9LFxuICB1cmw6IGZ1bmN0aW9uIHVybCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA8PSAyMDQ4ICYmICEhdmFsdWUubWF0Y2goZ2V0VXJsUmVnZXgoKSk7XG4gIH0sXG4gIGhleDogZnVuY3Rpb24gaGV4KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgISF2YWx1ZS5tYXRjaChwYXR0ZXJuJDIuaGV4KTtcbiAgfVxufTtcblxudmFyIHR5cGUkMSA9IGZ1bmN0aW9uIHR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKSB7XG4gIGlmIChydWxlLnJlcXVpcmVkICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXF1aXJlZCQxKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1c3RvbSA9IFsnaW50ZWdlcicsICdmbG9hdCcsICdhcnJheScsICdyZWdleHAnLCAnb2JqZWN0JywgJ21ldGhvZCcsICdlbWFpbCcsICdudW1iZXInLCAnZGF0ZScsICd1cmwnLCAnaGV4J107XG4gIHZhciBydWxlVHlwZSA9IHJ1bGUudHlwZTtcblxuICBpZiAoY3VzdG9tLmluZGV4T2YocnVsZVR5cGUpID4gLTEpIHtcbiAgICBpZiAoIXR5cGVzW3J1bGVUeXBlXSh2YWx1ZSkpIHtcbiAgICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzLnR5cGVzW3J1bGVUeXBlXSwgcnVsZS5mdWxsRmllbGQsIHJ1bGUudHlwZSkpO1xuICAgIH0gLy8gc3RyYWlnaHQgdHlwZW9mIGNoZWNrXG5cbiAgfSBlbHNlIGlmIChydWxlVHlwZSAmJiB0eXBlb2YgdmFsdWUgIT09IHJ1bGUudHlwZSkge1xuICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzLnR5cGVzW3J1bGVUeXBlXSwgcnVsZS5mdWxsRmllbGQsIHJ1bGUudHlwZSkpO1xuICB9XG59O1xuXG52YXIgcmFuZ2UgPSBmdW5jdGlvbiByYW5nZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpIHtcbiAgdmFyIGxlbiA9IHR5cGVvZiBydWxlLmxlbiA9PT0gJ251bWJlcic7XG4gIHZhciBtaW4gPSB0eXBlb2YgcnVsZS5taW4gPT09ICdudW1iZXInO1xuICB2YXIgbWF4ID0gdHlwZW9mIHJ1bGUubWF4ID09PSAnbnVtYmVyJzsgLy8g5q2j5YiZ5Yy56YWN56CB54K56IyD5Zu05LuOVSswMTAwMDDkuIDnm7TliLBVKzEwRkZGRueahOaWh+Wtl++8iOihpeWFheW5s+mdolN1cHBsZW1lbnRhcnkgUGxhbmXvvIlcblxuICB2YXIgc3BSZWdleHAgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nO1xuICB2YXIgdmFsID0gdmFsdWU7XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgbnVtID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgdmFyIHN0ciA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gIHZhciBhcnIgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcblxuICBpZiAobnVtKSB7XG4gICAga2V5ID0gJ251bWJlcic7XG4gIH0gZWxzZSBpZiAoc3RyKSB7XG4gICAga2V5ID0gJ3N0cmluZyc7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAga2V5ID0gJ2FycmF5JztcbiAgfSAvLyBpZiB0aGUgdmFsdWUgaXMgbm90IG9mIGEgc3VwcG9ydGVkIHR5cGUgZm9yIHJhbmdlIHZhbGlkYXRpb25cbiAgLy8gdGhlIHZhbGlkYXRpb24gcnVsZSBydWxlIHNob3VsZCB1c2UgdGhlXG4gIC8vIHR5cGUgcHJvcGVydHkgdG8gYWxzbyB0ZXN0IGZvciBhIHBhcnRpY3VsYXIgdHlwZVxuXG5cbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYXJyKSB7XG4gICAgdmFsID0gdmFsdWUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHN0cikge1xuICAgIC8vIOWkhOeQhueggeeCueWkp+S6jlUrMDEwMDAw55qE5paH5a2XbGVuZ3Ro5bGe5oCn5LiN5YeG56Gu55qEYnVn77yM5aaCXCLwoK638KCut/CgrrdcIi5sZW5naHQgIT09IDNcbiAgICB2YWwgPSB2YWx1ZS5yZXBsYWNlKHNwUmVnZXhwLCAnXycpLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChsZW4pIHtcbiAgICBpZiAodmFsICE9PSBydWxlLmxlbikge1xuICAgICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXNba2V5XS5sZW4sIHJ1bGUuZnVsbEZpZWxkLCBydWxlLmxlbikpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChtaW4gJiYgIW1heCAmJiB2YWwgPCBydWxlLm1pbikge1xuICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzW2tleV0ubWluLCBydWxlLmZ1bGxGaWVsZCwgcnVsZS5taW4pKTtcbiAgfSBlbHNlIGlmIChtYXggJiYgIW1pbiAmJiB2YWwgPiBydWxlLm1heCkge1xuICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzW2tleV0ubWF4LCBydWxlLmZ1bGxGaWVsZCwgcnVsZS5tYXgpKTtcbiAgfSBlbHNlIGlmIChtaW4gJiYgbWF4ICYmICh2YWwgPCBydWxlLm1pbiB8fCB2YWwgPiBydWxlLm1heCkpIHtcbiAgICBlcnJvcnMucHVzaChmb3JtYXQob3B0aW9ucy5tZXNzYWdlc1trZXldLnJhbmdlLCBydWxlLmZ1bGxGaWVsZCwgcnVsZS5taW4sIHJ1bGUubWF4KSk7XG4gIH1cbn07XG5cbnZhciBFTlVNJDEgPSAnZW51bSc7XG5cbnZhciBlbnVtZXJhYmxlJDEgPSBmdW5jdGlvbiBlbnVtZXJhYmxlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucykge1xuICBydWxlW0VOVU0kMV0gPSBBcnJheS5pc0FycmF5KHJ1bGVbRU5VTSQxXSkgPyBydWxlW0VOVU0kMV0gOiBbXTtcblxuICBpZiAocnVsZVtFTlVNJDFdLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgIGVycm9ycy5wdXNoKGZvcm1hdChvcHRpb25zLm1lc3NhZ2VzW0VOVU0kMV0sIHJ1bGUuZnVsbEZpZWxkLCBydWxlW0VOVU0kMV0uam9pbignLCAnKSkpO1xuICB9XG59O1xuXG52YXIgcGF0dGVybiQxID0gZnVuY3Rpb24gcGF0dGVybihydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpIHtcbiAgaWYgKHJ1bGUucGF0dGVybikge1xuICAgIGlmIChydWxlLnBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIGlmIGEgUmVnRXhwIGluc3RhbmNlIGlzIHBhc3NlZCwgcmVzZXQgYGxhc3RJbmRleGAgaW4gY2FzZSBpdHMgYGdsb2JhbGBcbiAgICAgIC8vIGZsYWcgaXMgYWNjaWRlbnRhbGx5IHNldCB0byBgdHJ1ZWAsIHdoaWNoIGluIGEgdmFsaWRhdGlvbiBzY2VuYXJpb1xuICAgICAgLy8gaXMgbm90IG5lY2Vzc2FyeSBhbmQgdGhlIHJlc3VsdCBtaWdodCBiZSBtaXNsZWFkaW5nXG4gICAgICBydWxlLnBhdHRlcm4ubGFzdEluZGV4ID0gMDtcblxuICAgICAgaWYgKCFydWxlLnBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXMucGF0dGVybi5taXNtYXRjaCwgcnVsZS5mdWxsRmllbGQsIHZhbHVlLCBydWxlLnBhdHRlcm4pKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBydWxlLnBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgX3BhdHRlcm4gPSBuZXcgUmVnRXhwKHJ1bGUucGF0dGVybik7XG5cbiAgICAgIGlmICghX3BhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZm9ybWF0KG9wdGlvbnMubWVzc2FnZXMucGF0dGVybi5taXNtYXRjaCwgcnVsZS5mdWxsRmllbGQsIHZhbHVlLCBydWxlLnBhdHRlcm4pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBydWxlcyA9IHtcbiAgcmVxdWlyZWQ6IHJlcXVpcmVkJDEsXG4gIHdoaXRlc3BhY2U6IHdoaXRlc3BhY2UsXG4gIHR5cGU6IHR5cGUkMSxcbiAgcmFuZ2U6IHJhbmdlLFxuICBcImVudW1cIjogZW51bWVyYWJsZSQxLFxuICBwYXR0ZXJuOiBwYXR0ZXJuJDFcbn07XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlLCAnc3RyaW5nJykgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucywgJ3N0cmluZycpO1xuXG4gICAgaWYgKCFpc0VtcHR5VmFsdWUodmFsdWUsICdzdHJpbmcnKSkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgcnVsZXMucmFuZ2UocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIHJ1bGVzLnBhdHRlcm4ocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcblxuICAgICAgaWYgKHJ1bGUud2hpdGVzcGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgICBydWxlcy53aGl0ZXNwYWNlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBtZXRob2QgPSBmdW5jdGlvbiBtZXRob2QocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBydWxlcy50eXBlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBudW1iZXIgPSBmdW5jdGlvbiBudW1iZXIocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBydWxlcy50eXBlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgICBydWxlcy5yYW5nZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xuXG52YXIgX2Jvb2xlYW4gPSBmdW5jdGlvbiBfYm9vbGVhbihydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIHJlZ2V4cCA9IGZ1bmN0aW9uIHJlZ2V4cChydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFpc0VtcHR5VmFsdWUodmFsdWUpKSB7XG4gICAgICBydWxlcy50eXBlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBpbnRlZ2VyID0gZnVuY3Rpb24gaW50ZWdlcihydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIHJ1bGVzLnJhbmdlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBmbG9hdEZuID0gZnVuY3Rpb24gZmxvYXRGbihydWxlLCB2YWx1ZSwgY2FsbGJhY2ssIHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bGVzLnR5cGUocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgIHJ1bGVzLnJhbmdlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBhcnJheSA9IGZ1bmN0aW9uIGFycmF5KHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKCh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zLCAnYXJyYXknKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBydWxlcy50eXBlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgICBydWxlcy5yYW5nZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xuXG52YXIgb2JqZWN0ID0gZnVuY3Rpb24gb2JqZWN0KHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVsZXMudHlwZShydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xuXG52YXIgRU5VTSA9ICdlbnVtJztcblxudmFyIGVudW1lcmFibGUgPSBmdW5jdGlvbiBlbnVtZXJhYmxlKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSkgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVsZXNbRU5VTV0ocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjayhlcnJvcnMpO1xufTtcblxudmFyIHBhdHRlcm4gPSBmdW5jdGlvbiBwYXR0ZXJuKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHZhbGlkYXRlID0gcnVsZS5yZXF1aXJlZCB8fCAhcnVsZS5yZXF1aXJlZCAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkocnVsZS5maWVsZCk7XG5cbiAgaWYgKHZhbGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZSh2YWx1ZSwgJ3N0cmluZycpICYmICFydWxlLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBydWxlcy5yZXF1aXJlZChydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFpc0VtcHR5VmFsdWUodmFsdWUsICdzdHJpbmcnKSkge1xuICAgICAgcnVsZXMucGF0dGVybihydWxlLCB2YWx1ZSwgc291cmNlLCBlcnJvcnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xuXG52YXIgZGF0ZSA9IGZ1bmN0aW9uIGRhdGUocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgLy8gY29uc29sZS5sb2coJ2ludGVnZXIgcnVsZSBjYWxsZWQgJWonLCBydWxlKTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTsgLy8gY29uc29sZS5sb2coJ3ZhbGlkYXRlIG9uICVzIHZhbHVlJywgdmFsdWUpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUsICdkYXRlJykgJiYgIXJ1bGUucmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICBpZiAoIWlzRW1wdHlWYWx1ZSh2YWx1ZSwgJ2RhdGUnKSkge1xuICAgICAgdmFyIGRhdGVPYmplY3Q7XG5cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgZGF0ZU9iamVjdCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZU9iamVjdCA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcnVsZXMudHlwZShydWxlLCBkYXRlT2JqZWN0LCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChkYXRlT2JqZWN0KSB7XG4gICAgICAgIHJ1bGVzLnJhbmdlKHJ1bGUsIGRhdGVPYmplY3QuZ2V0VGltZSgpLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciByZXF1aXJlZCA9IGZ1bmN0aW9uIHJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBjYWxsYmFjaywgc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHR5cGUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/ICdhcnJheScgOiB0eXBlb2YgdmFsdWU7XG4gIHJ1bGVzLnJlcXVpcmVkKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucywgdHlwZSk7XG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xuXG52YXIgdHlwZSA9IGZ1bmN0aW9uIHR5cGUocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIHJ1bGVUeXBlID0gcnVsZS50eXBlO1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB2YWxpZGF0ZSA9IHJ1bGUucmVxdWlyZWQgfHwgIXJ1bGUucmVxdWlyZWQgJiYgc291cmNlLmhhc093blByb3BlcnR5KHJ1bGUuZmllbGQpO1xuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0VtcHR5VmFsdWUodmFsdWUsIHJ1bGVUeXBlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zLCBydWxlVHlwZSk7XG5cbiAgICBpZiAoIWlzRW1wdHlWYWx1ZSh2YWx1ZSwgcnVsZVR5cGUpKSB7XG4gICAgICBydWxlcy50eXBlKHJ1bGUsIHZhbHVlLCBzb3VyY2UsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3JzKTtcbn07XG5cbnZhciBhbnkgPSBmdW5jdGlvbiBhbnkocnVsZSwgdmFsdWUsIGNhbGxiYWNrLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdmFsaWRhdGUgPSBydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShydWxlLmZpZWxkKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBpZiAoaXNFbXB0eVZhbHVlKHZhbHVlKSAmJiAhcnVsZS5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcnVsZXMucmVxdWlyZWQocnVsZSwgdmFsdWUsIHNvdXJjZSwgZXJyb3JzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9ycyk7XG59O1xuXG52YXIgdmFsaWRhdG9ycyA9IHtcbiAgc3RyaW5nOiBzdHJpbmcsXG4gIG1ldGhvZDogbWV0aG9kLFxuICBudW1iZXI6IG51bWJlcixcbiAgXCJib29sZWFuXCI6IF9ib29sZWFuLFxuICByZWdleHA6IHJlZ2V4cCxcbiAgaW50ZWdlcjogaW50ZWdlcixcbiAgXCJmbG9hdFwiOiBmbG9hdEZuLFxuICBhcnJheTogYXJyYXksXG4gIG9iamVjdDogb2JqZWN0LFxuICBcImVudW1cIjogZW51bWVyYWJsZSxcbiAgcGF0dGVybjogcGF0dGVybixcbiAgZGF0ZTogZGF0ZSxcbiAgdXJsOiB0eXBlLFxuICBoZXg6IHR5cGUsXG4gIGVtYWlsOiB0eXBlLFxuICByZXF1aXJlZDogcmVxdWlyZWQsXG4gIGFueTogYW55XG59O1xuXG5mdW5jdGlvbiBuZXdNZXNzYWdlcygpIHtcbiAgcmV0dXJuIHtcbiAgICBcImRlZmF1bHRcIjogJ1ZhbGlkYXRpb24gZXJyb3Igb24gZmllbGQgJXMnLFxuICAgIHJlcXVpcmVkOiAnJXMgaXMgcmVxdWlyZWQnLFxuICAgIFwiZW51bVwiOiAnJXMgbXVzdCBiZSBvbmUgb2YgJXMnLFxuICAgIHdoaXRlc3BhY2U6ICclcyBjYW5ub3QgYmUgZW1wdHknLFxuICAgIGRhdGU6IHtcbiAgICAgIGZvcm1hdDogJyVzIGRhdGUgJXMgaXMgaW52YWxpZCBmb3IgZm9ybWF0ICVzJyxcbiAgICAgIHBhcnNlOiAnJXMgZGF0ZSBjb3VsZCBub3QgYmUgcGFyc2VkLCAlcyBpcyBpbnZhbGlkICcsXG4gICAgICBpbnZhbGlkOiAnJXMgZGF0ZSAlcyBpcyBpbnZhbGlkJ1xuICAgIH0sXG4gICAgdHlwZXM6IHtcbiAgICAgIHN0cmluZzogJyVzIGlzIG5vdCBhICVzJyxcbiAgICAgIG1ldGhvZDogJyVzIGlzIG5vdCBhICVzIChmdW5jdGlvbiknLFxuICAgICAgYXJyYXk6ICclcyBpcyBub3QgYW4gJXMnLFxuICAgICAgb2JqZWN0OiAnJXMgaXMgbm90IGFuICVzJyxcbiAgICAgIG51bWJlcjogJyVzIGlzIG5vdCBhICVzJyxcbiAgICAgIGRhdGU6ICclcyBpcyBub3QgYSAlcycsXG4gICAgICBcImJvb2xlYW5cIjogJyVzIGlzIG5vdCBhICVzJyxcbiAgICAgIGludGVnZXI6ICclcyBpcyBub3QgYW4gJXMnLFxuICAgICAgXCJmbG9hdFwiOiAnJXMgaXMgbm90IGEgJXMnLFxuICAgICAgcmVnZXhwOiAnJXMgaXMgbm90IGEgdmFsaWQgJXMnLFxuICAgICAgZW1haWw6ICclcyBpcyBub3QgYSB2YWxpZCAlcycsXG4gICAgICB1cmw6ICclcyBpcyBub3QgYSB2YWxpZCAlcycsXG4gICAgICBoZXg6ICclcyBpcyBub3QgYSB2YWxpZCAlcydcbiAgICB9LFxuICAgIHN0cmluZzoge1xuICAgICAgbGVuOiAnJXMgbXVzdCBiZSBleGFjdGx5ICVzIGNoYXJhY3RlcnMnLFxuICAgICAgbWluOiAnJXMgbXVzdCBiZSBhdCBsZWFzdCAlcyBjaGFyYWN0ZXJzJyxcbiAgICAgIG1heDogJyVzIGNhbm5vdCBiZSBsb25nZXIgdGhhbiAlcyBjaGFyYWN0ZXJzJyxcbiAgICAgIHJhbmdlOiAnJXMgbXVzdCBiZSBiZXR3ZWVuICVzIGFuZCAlcyBjaGFyYWN0ZXJzJ1xuICAgIH0sXG4gICAgbnVtYmVyOiB7XG4gICAgICBsZW46ICclcyBtdXN0IGVxdWFsICVzJyxcbiAgICAgIG1pbjogJyVzIGNhbm5vdCBiZSBsZXNzIHRoYW4gJXMnLFxuICAgICAgbWF4OiAnJXMgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAlcycsXG4gICAgICByYW5nZTogJyVzIG11c3QgYmUgYmV0d2VlbiAlcyBhbmQgJXMnXG4gICAgfSxcbiAgICBhcnJheToge1xuICAgICAgbGVuOiAnJXMgbXVzdCBiZSBleGFjdGx5ICVzIGluIGxlbmd0aCcsXG4gICAgICBtaW46ICclcyBjYW5ub3QgYmUgbGVzcyB0aGFuICVzIGluIGxlbmd0aCcsXG4gICAgICBtYXg6ICclcyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuICVzIGluIGxlbmd0aCcsXG4gICAgICByYW5nZTogJyVzIG11c3QgYmUgYmV0d2VlbiAlcyBhbmQgJXMgaW4gbGVuZ3RoJ1xuICAgIH0sXG4gICAgcGF0dGVybjoge1xuICAgICAgbWlzbWF0Y2g6ICclcyB2YWx1ZSAlcyBkb2VzIG5vdCBtYXRjaCBwYXR0ZXJuICVzJ1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgdmFyIGNsb25lZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcykpO1xuICAgICAgY2xvbmVkLmNsb25lID0gdGhpcy5jbG9uZTtcbiAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfVxuICB9O1xufVxudmFyIG1lc3NhZ2VzID0gbmV3TWVzc2FnZXMoKTtcblxuLyoqXG4gKiAgRW5jYXBzdWxhdGVzIGEgdmFsaWRhdGlvbiBzY2hlbWEuXG4gKlxuICogIEBwYXJhbSBkZXNjcmlwdG9yIEFuIG9iamVjdCBkZWNsYXJpbmcgdmFsaWRhdGlvbiBydWxlc1xuICogIGZvciB0aGlzIHNjaGVtYS5cbiAqL1xuXG52YXIgU2NoZW1hID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBTdGF0aWMgPT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT0gSW5zdGFuY2UgPT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIFNjaGVtYShkZXNjcmlwdG9yKSB7XG4gICAgdGhpcy5ydWxlcyA9IG51bGw7XG4gICAgdGhpcy5fbWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICB0aGlzLmRlZmluZShkZXNjcmlwdG9yKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTY2hlbWEucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUocnVsZXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCFydWxlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uZmlndXJlIGEgc2NoZW1hIHdpdGggbm8gcnVsZXMnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJ1bGVzICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHJ1bGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhydWxlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGl0ZW0gPSBydWxlc1tuYW1lXTtcbiAgICAgIF90aGlzLnJ1bGVzW25hbWVdID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IGl0ZW0gOiBbaXRlbV07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLm1lc3NhZ2VzID0gZnVuY3Rpb24gbWVzc2FnZXMoX21lc3NhZ2VzKSB7XG4gICAgaWYgKF9tZXNzYWdlcykge1xuICAgICAgdGhpcy5fbWVzc2FnZXMgPSBkZWVwTWVyZ2UobmV3TWVzc2FnZXMoKSwgX21lc3NhZ2VzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbWVzc2FnZXM7XG4gIH07XG5cbiAgX3Byb3RvLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoc291cmNlXywgbywgb2MpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmIChvID09PSB2b2lkIDApIHtcbiAgICAgIG8gPSB7fTtcbiAgICB9XG5cbiAgICBpZiAob2MgPT09IHZvaWQgMCkge1xuICAgICAgb2MgPSBmdW5jdGlvbiBvYygpIHt9O1xuICAgIH1cblxuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VfO1xuICAgIHZhciBvcHRpb25zID0gbztcbiAgICB2YXIgY2FsbGJhY2sgPSBvYztcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5ydWxlcyB8fCBPYmplY3Qua2V5cyh0aGlzLnJ1bGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGUocmVzdWx0cykge1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIGZpZWxkcyA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBhZGQoZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgICAgIHZhciBfZXJyb3JzO1xuXG4gICAgICAgICAgZXJyb3JzID0gKF9lcnJvcnMgPSBlcnJvcnMpLmNvbmNhdC5hcHBseShfZXJyb3JzLCBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWRkKHJlc3VsdHNbaV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpZWxkcyA9IGNvbnZlcnRGaWVsZHNFcnJvcihlcnJvcnMpO1xuICAgICAgICBjYWxsYmFjayhlcnJvcnMsIGZpZWxkcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWVzc2FnZXMpIHtcbiAgICAgIHZhciBtZXNzYWdlcyQxID0gdGhpcy5tZXNzYWdlcygpO1xuXG4gICAgICBpZiAobWVzc2FnZXMkMSA9PT0gbWVzc2FnZXMpIHtcbiAgICAgICAgbWVzc2FnZXMkMSA9IG5ld01lc3NhZ2VzKCk7XG4gICAgICB9XG5cbiAgICAgIGRlZXBNZXJnZShtZXNzYWdlcyQxLCBvcHRpb25zLm1lc3NhZ2VzKTtcbiAgICAgIG9wdGlvbnMubWVzc2FnZXMgPSBtZXNzYWdlcyQxO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLm1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcygpO1xuICAgIH1cblxuICAgIHZhciBzZXJpZXMgPSB7fTtcbiAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cyB8fCBPYmplY3Qua2V5cyh0aGlzLnJ1bGVzKTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKHopIHtcbiAgICAgIHZhciBhcnIgPSBfdGhpczIucnVsZXNbel07XG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vbel07XG4gICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgICB2YXIgcnVsZSA9IHI7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBydWxlLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmIChzb3VyY2UgPT09IHNvdXJjZV8pIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IF9leHRlbmRzKHt9LCBzb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gc291cmNlW3pdID0gcnVsZS50cmFuc2Zvcm0odmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBydWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcnVsZSA9IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogcnVsZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnVsZSA9IF9leHRlbmRzKHt9LCBydWxlKTtcbiAgICAgICAgfSAvLyBGaWxsIHZhbGlkYXRvci4gU2tpcCBpZiBub3RoaW5nIG5lZWQgdG8gdmFsaWRhdGVcblxuXG4gICAgICAgIHJ1bGUudmFsaWRhdG9yID0gX3RoaXMyLmdldFZhbGlkYXRpb25NZXRob2QocnVsZSk7XG5cbiAgICAgICAgaWYgKCFydWxlLnZhbGlkYXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bGUuZmllbGQgPSB6O1xuICAgICAgICBydWxlLmZ1bGxGaWVsZCA9IHJ1bGUuZnVsbEZpZWxkIHx8IHo7XG4gICAgICAgIHJ1bGUudHlwZSA9IF90aGlzMi5nZXRUeXBlKHJ1bGUpO1xuICAgICAgICBzZXJpZXNbel0gPSBzZXJpZXNbel0gfHwgW107XG4gICAgICAgIHNlcmllc1t6XS5wdXNoKHtcbiAgICAgICAgICBydWxlOiBydWxlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBmaWVsZDogelxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBlcnJvckZpZWxkcyA9IHt9O1xuICAgIHJldHVybiBhc3luY01hcChzZXJpZXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChkYXRhLCBkb0l0KSB7XG4gICAgICB2YXIgcnVsZSA9IGRhdGEucnVsZTtcbiAgICAgIHZhciBkZWVwID0gKHJ1bGUudHlwZSA9PT0gJ29iamVjdCcgfHwgcnVsZS50eXBlID09PSAnYXJyYXknKSAmJiAodHlwZW9mIHJ1bGUuZmllbGRzID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcnVsZS5kZWZhdWx0RmllbGQgPT09ICdvYmplY3QnKTtcbiAgICAgIGRlZXAgPSBkZWVwICYmIChydWxlLnJlcXVpcmVkIHx8ICFydWxlLnJlcXVpcmVkICYmIGRhdGEudmFsdWUpO1xuICAgICAgcnVsZS5maWVsZCA9IGRhdGEuZmllbGQ7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZEZ1bGxGaWVsZChrZXksIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHNjaGVtYSwge1xuICAgICAgICAgIGZ1bGxGaWVsZDogcnVsZS5mdWxsRmllbGQgKyBcIi5cIiArIGtleSxcbiAgICAgICAgICBmdWxsRmllbGRzOiBydWxlLmZ1bGxGaWVsZHMgPyBbXS5jb25jYXQocnVsZS5mdWxsRmllbGRzLCBba2V5XSkgOiBba2V5XVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2IoZSkge1xuICAgICAgICBpZiAoZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVycm9yTGlzdCA9IEFycmF5LmlzQXJyYXkoZSkgPyBlIDogW2VdO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5zdXBwcmVzc1dhcm5pbmcgJiYgZXJyb3JMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgIFNjaGVtYS53YXJuaW5nKCdhc3luYy12YWxpZGF0b3I6JywgZXJyb3JMaXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvckxpc3QubGVuZ3RoICYmIHJ1bGUubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXJyb3JMaXN0ID0gW10uY29uY2F0KHJ1bGUubWVzc2FnZSk7XG4gICAgICAgIH0gLy8gRmlsbCBlcnJvciBpbmZvXG5cblxuICAgICAgICB2YXIgZmlsbGVkRXJyb3JzID0gZXJyb3JMaXN0Lm1hcChjb21wbGVtZW50RXJyb3IocnVsZSwgc291cmNlKSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmlyc3QgJiYgZmlsbGVkRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIGVycm9yRmllbGRzW3J1bGUuZmllbGRdID0gMTtcbiAgICAgICAgICByZXR1cm4gZG9JdChmaWxsZWRFcnJvcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkZWVwKSB7XG4gICAgICAgICAgZG9JdChmaWxsZWRFcnJvcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIHJ1bGUgaXMgcmVxdWlyZWQgYnV0IHRoZSB0YXJnZXQgb2JqZWN0XG4gICAgICAgICAgLy8gZG9lcyBub3QgZXhpc3QgZmFpbCBhdCB0aGUgcnVsZSBsZXZlbCBhbmQgZG9uJ3RcbiAgICAgICAgICAvLyBnbyBkZWVwZXJcbiAgICAgICAgICBpZiAocnVsZS5yZXF1aXJlZCAmJiAhZGF0YS52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHJ1bGUubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZpbGxlZEVycm9ycyA9IFtdLmNvbmNhdChydWxlLm1lc3NhZ2UpLm1hcChjb21wbGVtZW50RXJyb3IocnVsZSwgc291cmNlKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgZmlsbGVkRXJyb3JzID0gW29wdGlvbnMuZXJyb3IocnVsZSwgZm9ybWF0KG9wdGlvbnMubWVzc2FnZXMucmVxdWlyZWQsIHJ1bGUuZmllbGQpKV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkb0l0KGZpbGxlZEVycm9ycyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGZpZWxkc1NjaGVtYSA9IHt9O1xuXG4gICAgICAgICAgaWYgKHJ1bGUuZGVmYXVsdEZpZWxkKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhLnZhbHVlKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICBmaWVsZHNTY2hlbWFba2V5XSA9IHJ1bGUuZGVmYXVsdEZpZWxkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmllbGRzU2NoZW1hID0gX2V4dGVuZHMoe30sIGZpZWxkc1NjaGVtYSwgZGF0YS5ydWxlLmZpZWxkcyk7XG4gICAgICAgICAgdmFyIHBhcmVkRmllbGRzU2NoZW1hID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXMoZmllbGRzU2NoZW1hKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkU2NoZW1hID0gZmllbGRzU2NoZW1hW2ZpZWxkXTtcbiAgICAgICAgICAgIHZhciBmaWVsZFNjaGVtYUxpc3QgPSBBcnJheS5pc0FycmF5KGZpZWxkU2NoZW1hKSA/IGZpZWxkU2NoZW1hIDogW2ZpZWxkU2NoZW1hXTtcbiAgICAgICAgICAgIHBhcmVkRmllbGRzU2NoZW1hW2ZpZWxkXSA9IGZpZWxkU2NoZW1hTGlzdC5tYXAoYWRkRnVsbEZpZWxkLmJpbmQobnVsbCwgZmllbGQpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc2NoZW1hID0gbmV3IFNjaGVtYShwYXJlZEZpZWxkc1NjaGVtYSk7XG4gICAgICAgICAgc2NoZW1hLm1lc3NhZ2VzKG9wdGlvbnMubWVzc2FnZXMpO1xuXG4gICAgICAgICAgaWYgKGRhdGEucnVsZS5vcHRpb25zKSB7XG4gICAgICAgICAgICBkYXRhLnJ1bGUub3B0aW9ucy5tZXNzYWdlcyA9IG9wdGlvbnMubWVzc2FnZXM7XG4gICAgICAgICAgICBkYXRhLnJ1bGUub3B0aW9ucy5lcnJvciA9IG9wdGlvbnMuZXJyb3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NoZW1hLnZhbGlkYXRlKGRhdGEudmFsdWUsIGRhdGEucnVsZS5vcHRpb25zIHx8IG9wdGlvbnMsIGZ1bmN0aW9uIChlcnJzKSB7XG4gICAgICAgICAgICB2YXIgZmluYWxFcnJvcnMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGZpbGxlZEVycm9ycyAmJiBmaWxsZWRFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZpbmFsRXJyb3JzLnB1c2guYXBwbHkoZmluYWxFcnJvcnMsIGZpbGxlZEVycm9ycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnJzICYmIGVycnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZpbmFsRXJyb3JzLnB1c2guYXBwbHkoZmluYWxFcnJvcnMsIGVycnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb0l0KGZpbmFsRXJyb3JzLmxlbmd0aCA/IGZpbmFsRXJyb3JzIDogbnVsbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlcztcblxuICAgICAgaWYgKHJ1bGUuYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgcmVzID0gcnVsZS5hc3luY1ZhbGlkYXRvcihydWxlLCBkYXRhLnZhbHVlLCBjYiwgZGF0YS5zb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChydWxlLnZhbGlkYXRvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IHJ1bGUudmFsaWRhdG9yKHJ1bGUsIGRhdGEudmFsdWUsIGNiLCBkYXRhLnNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvciA9PSBudWxsID8gdm9pZCAwIDogY29uc29sZS5lcnJvcihlcnJvcik7IC8vIHJldGhyb3cgdG8gcmVwb3J0IGVycm9yXG5cbiAgICAgICAgICBpZiAoIW9wdGlvbnMuc3VwcHJlc3NWYWxpZGF0b3JFcnJvcikge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzID09PSB0cnVlKSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY2IodHlwZW9mIHJ1bGUubWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyA/IHJ1bGUubWVzc2FnZShydWxlLmZ1bGxGaWVsZCB8fCBydWxlLmZpZWxkKSA6IHJ1bGUubWVzc2FnZSB8fCAocnVsZS5mdWxsRmllbGQgfHwgcnVsZS5maWVsZCkgKyBcIiBmYWlsc1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIGNiKHJlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBjYihyZXMubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlcyAmJiByZXMudGhlbikge1xuICAgICAgICByZXMudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgY29tcGxldGUocmVzdWx0cyk7XG4gICAgfSwgc291cmNlKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUocnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgPT09IHVuZGVmaW5lZCAmJiBydWxlLnBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJ1bGUudHlwZSA9ICdwYXR0ZXJuJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJ1bGUudmFsaWRhdG9yICE9PSAnZnVuY3Rpb24nICYmIHJ1bGUudHlwZSAmJiAhdmFsaWRhdG9ycy5oYXNPd25Qcm9wZXJ0eShydWxlLnR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCdVbmtub3duIHJ1bGUgdHlwZSAlcycsIHJ1bGUudHlwZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBydWxlLnR5cGUgfHwgJ3N0cmluZyc7XG4gIH07XG5cbiAgX3Byb3RvLmdldFZhbGlkYXRpb25NZXRob2QgPSBmdW5jdGlvbiBnZXRWYWxpZGF0aW9uTWV0aG9kKHJ1bGUpIHtcbiAgICBpZiAodHlwZW9mIHJ1bGUudmFsaWRhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcnVsZS52YWxpZGF0b3I7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhydWxlKTtcbiAgICB2YXIgbWVzc2FnZUluZGV4ID0ga2V5cy5pbmRleE9mKCdtZXNzYWdlJyk7XG5cbiAgICBpZiAobWVzc2FnZUluZGV4ICE9PSAtMSkge1xuICAgICAga2V5cy5zcGxpY2UobWVzc2FnZUluZGV4LCAxKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgcmV0dXJuIHZhbGlkYXRvcnMucmVxdWlyZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvcnNbdGhpcy5nZXRUeXBlKHJ1bGUpXSB8fCB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcmV0dXJuIFNjaGVtYTtcbn0oKTtcblxuU2NoZW1hLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIodHlwZSwgdmFsaWRhdG9yKSB7XG4gIGlmICh0eXBlb2YgdmFsaWRhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVnaXN0ZXIgYSB2YWxpZGF0b3IgYnkgdHlwZSwgdmFsaWRhdG9yIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YWxpZGF0b3JzW3R5cGVdID0gdmFsaWRhdG9yO1xufTtcblxuU2NoZW1hLndhcm5pbmcgPSB3YXJuaW5nO1xuU2NoZW1hLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG5TY2hlbWEudmFsaWRhdG9ycyA9IHZhbGlkYXRvcnM7XG5cbmV4cG9ydCB7IFNjaGVtYSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfaW5oZXJpdHNMb29zZSIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiX3NldFByb3RvdHlwZU9mIiwiX2dldFByb3RvdHlwZU9mIiwibyIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJwIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsImUiLCJfY29uc3RydWN0IiwiUGFyZW50IiwiYXJncyIsIkNsYXNzIiwiYSIsInB1c2giLCJDb25zdHJ1Y3RvciIsIkZ1bmN0aW9uIiwiaW5zdGFuY2UiLCJfaXNOYXRpdmVGdW5jdGlvbiIsImZuIiwidG9TdHJpbmciLCJpbmRleE9mIiwiX3dyYXBOYXRpdmVTdXBlciIsIl9jYWNoZSIsIk1hcCIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsImhhcyIsImdldCIsInNldCIsIldyYXBwZXIiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImZvcm1hdFJlZ0V4cCIsIndhcm5pbmciLCJwcm9jZXNzIiwiZW52IiwiZG9jdW1lbnQiLCJ0eXBlIiwiZXJyb3JzIiwiY29uc29sZSIsIndhcm4iLCJBU1lOQ19WQUxJREFUT1JfTk9fV0FSTklORyIsImV2ZXJ5IiwiY29udmVydEZpZWxkc0Vycm9yIiwiZmllbGRzIiwiZm9yRWFjaCIsImVycm9yIiwiZmllbGQiLCJmb3JtYXQiLCJ0ZW1wbGF0ZSIsIl9sZW4iLCJBcnJheSIsIl9rZXkiLCJsZW4iLCJzdHIiLCJyZXBsYWNlIiwieCIsIlN0cmluZyIsIk51bWJlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJfIiwiaXNOYXRpdmVTdHJpbmdUeXBlIiwiaXNFbXB0eVZhbHVlIiwiaXNBcnJheSIsImFzeW5jUGFyYWxsZWxBcnJheSIsImFyciIsImZ1bmMiLCJjYWxsYmFjayIsInJlc3VsdHMiLCJ0b3RhbCIsImFyckxlbmd0aCIsImNvdW50IiwiYXN5bmNTZXJpYWxBcnJheSIsImluZGV4IiwibmV4dCIsIm9yaWdpbmFsIiwiZmxhdHRlbk9iakFyciIsIm9iakFyciIsInJldCIsImtleXMiLCJrIiwiQXN5bmNWYWxpZGF0aW9uRXJyb3IiLCJfRXJyb3IiLCJfdGhpcyIsIkVycm9yIiwiYXN5bmNNYXAiLCJvcHRpb24iLCJmaXJzdCIsIl9wZW5kaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmbGF0dGVuQXJyIiwiZmlyc3RGaWVsZHMiLCJvYmpBcnJLZXlzIiwib2JqQXJyTGVuZ3RoIiwicGVuZGluZyIsImlzRXJyb3JPYmoiLCJvYmoiLCJtZXNzYWdlIiwiZ2V0VmFsdWUiLCJwYXRoIiwidiIsImNvbXBsZW1lbnRFcnJvciIsInJ1bGUiLCJvZSIsImZpZWxkVmFsdWUiLCJmdWxsRmllbGRzIiwiZnVsbEZpZWxkIiwiZGVlcE1lcmdlIiwicyIsInJlcXVpcmVkJDEiLCJyZXF1aXJlZCIsIm9wdGlvbnMiLCJtZXNzYWdlcyIsIndoaXRlc3BhY2UiLCJ0ZXN0IiwidXJsUmVnIiwiZ2V0VXJsUmVnZXgiLCJ3b3JkIiwiYiIsImluY2x1ZGVCb3VuZGFyaWVzIiwidjQiLCJ2NnNlZyIsInY2IiwidHJpbSIsInY0NkV4YWN0IiwiUmVnRXhwIiwidjRleGFjdCIsInY2ZXhhY3QiLCJpcCIsImV4YWN0IiwicHJvdG9jb2wiLCJhdXRoIiwiaXB2NCIsImlwdjYiLCJob3N0IiwiZG9tYWluIiwidGxkIiwicG9ydCIsInJlZ2V4IiwicGF0dGVybiQyIiwiZW1haWwiLCJoZXgiLCJ0eXBlcyIsImludGVnZXIiLCJudW1iZXIiLCJwYXJzZUludCIsImZsb2F0IiwiYXJyYXkiLCJyZWdleHAiLCJkYXRlIiwiZ2V0VGltZSIsImdldE1vbnRoIiwiZ2V0WWVhciIsImlzTmFOIiwib2JqZWN0IiwibWV0aG9kIiwibWF0Y2giLCJ1cmwiLCJ0eXBlJDEiLCJjdXN0b20iLCJydWxlVHlwZSIsInJhbmdlIiwibWluIiwibWF4Iiwic3BSZWdleHAiLCJ2YWwiLCJudW0iLCJFTlVNJDEiLCJlbnVtZXJhYmxlJDEiLCJqb2luIiwicGF0dGVybiQxIiwicGF0dGVybiIsImxhc3RJbmRleCIsIm1pc21hdGNoIiwiX3BhdHRlcm4iLCJydWxlcyIsInN0cmluZyIsInZhbGlkYXRlIiwiX2Jvb2xlYW4iLCJmbG9hdEZuIiwiRU5VTSIsImRhdGVPYmplY3QiLCJEYXRlIiwiYW55IiwidmFsaWRhdG9ycyIsIm5ld01lc3NhZ2VzIiwicGFyc2UiLCJpbnZhbGlkIiwiY2xvbmUiLCJjbG9uZWQiLCJTY2hlbWEiLCJkZXNjcmlwdG9yIiwiX21lc3NhZ2VzIiwiZGVmaW5lIiwiX3Byb3RvIiwibmFtZSIsIml0ZW0iLCJzb3VyY2VfIiwib2MiLCJfdGhpczIiLCJjb21wbGV0ZSIsImFkZCIsIl9lcnJvcnMiLCJjb25jYXQiLCJtZXNzYWdlcyQxIiwic2VyaWVzIiwieiIsInIiLCJ0cmFuc2Zvcm0iLCJ2YWxpZGF0b3IiLCJnZXRWYWxpZGF0aW9uTWV0aG9kIiwiZ2V0VHlwZSIsImVycm9yRmllbGRzIiwiZGF0YSIsImRvSXQiLCJkZWVwIiwiZGVmYXVsdEZpZWxkIiwiYWRkRnVsbEZpZWxkIiwic2NoZW1hIiwiY2IiLCJlcnJvckxpc3QiLCJzdXBwcmVzc1dhcm5pbmciLCJmaWxsZWRFcnJvcnMiLCJtYXAiLCJmaWVsZHNTY2hlbWEiLCJwYXJlZEZpZWxkc1NjaGVtYSIsImZpZWxkU2NoZW1hIiwiZmllbGRTY2hlbWFMaXN0IiwiZXJycyIsImZpbmFsRXJyb3JzIiwicmVzIiwiYXN5bmNWYWxpZGF0b3IiLCJzdXBwcmVzc1ZhbGlkYXRvckVycm9yIiwic2V0VGltZW91dCIsInRoZW4iLCJtZXNzYWdlSW5kZXgiLCJzcGxpY2UiLCJyZWdpc3RlciIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/async-validator/dist-web/index.js\n");

/***/ })

};
;